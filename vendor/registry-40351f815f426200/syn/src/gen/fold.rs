// THIS FILE IS AUTOMATICALLY GENERATED; DO NOT EDIT

#![allow(unreachable_code)]
#[cfg(any(feature = "full", feature = "derive"))]
use gen::helper::fold::*;
use proc_macro2::Span;
#[cfg(any(feature = "full", feature = "derive"))]
use token::{Brace, Bracket, Group, Paren};
use *;
#[cfg(feature = "full")]
macro_rules! full {
    ($e:expr) => {
        $e
    };
}
#[cfg(all(feature = "derive", not(feature = "full")))]
macro_rules! full {
    ($e:expr) => {
        unreachable!()
    };
}
/// Syntax tree traversal to transform the nodes of an owned syntax tree.
///
/// See the [module documentation] for details.
///
/// [module documentation]: index.html
///
/// *This trait is available if Syn is built with the `"fold"` feature.*
pub trait Fold {
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_abi(&mut self, i: Abi) -> Abi {
        fold_abi(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_angle_bracketed_generic_arguments(
        &mut self,
        i: AngleBracketedGenericArguments,
    ) -> AngleBracketedGenericArguments {
        fold_angle_bracketed_generic_arguments(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_arg_captured(&mut self, i: ArgCaptured) -> ArgCaptured {
        fold_arg_captured(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_arg_self(&mut self, i: ArgSelf) -> ArgSelf {
        fold_arg_self(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_arg_self_ref(&mut self, i: ArgSelfRef) -> ArgSelfRef {
        fold_arg_self_ref(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_arm(&mut self, i: Arm) -> Arm {
        fold_arm(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_attr_style(&mut self, i: AttrStyle) -> AttrStyle {
        fold_attr_style(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_attribute(&mut self, i: Attribute) -> Attribute {
        fold_attribute(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_bare_fn_arg(&mut self, i: BareFnArg) -> BareFnArg {
        fold_bare_fn_arg(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_bare_fn_arg_name(&mut self, i: BareFnArgName) -> BareFnArgName {
        fold_bare_fn_arg_name(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_bin_op(&mut self, i: BinOp) -> BinOp {
        fold_bin_op(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_binding(&mut self, i: Binding) -> Binding {
        fold_binding(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_block(&mut self, i: Block) -> Block {
        fold_block(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_bound_lifetimes(&mut self, i: BoundLifetimes) -> BoundLifetimes {
        fold_bound_lifetimes(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_const_param(&mut self, i: ConstParam) -> ConstParam {
        fold_const_param(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_constraint(&mut self, i: Constraint) -> Constraint {
        fold_constraint(self, i)
    }
    #[cfg(feature = "derive")]
    fn fold_data(&mut self, i: Data) -> Data {
        fold_data(self, i)
    }
    #[cfg(feature = "derive")]
    fn fold_data_enum(&mut self, i: DataEnum) -> DataEnum {
        fold_data_enum(self, i)
    }
    #[cfg(feature = "derive")]
    fn fold_data_struct(&mut self, i: DataStruct) -> DataStruct {
        fold_data_struct(self, i)
    }
    #[cfg(feature = "derive")]
    fn fold_data_union(&mut self, i: DataUnion) -> DataUnion {
        fold_data_union(self, i)
    }
    #[cfg(feature = "derive")]
    fn fold_derive_input(&mut self, i: DeriveInput) -> DeriveInput {
        fold_derive_input(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_expr(&mut self, i: Expr) -> Expr {
        fold_expr(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_array(&mut self, i: ExprArray) -> ExprArray {
        fold_expr_array(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_assign(&mut self, i: ExprAssign) -> ExprAssign {
        fold_expr_assign(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_assign_op(&mut self, i: ExprAssignOp) -> ExprAssignOp {
        fold_expr_assign_op(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_async(&mut self, i: ExprAsync) -> ExprAsync {
        fold_expr_async(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_expr_binary(&mut self, i: ExprBinary) -> ExprBinary {
        fold_expr_binary(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_block(&mut self, i: ExprBlock) -> ExprBlock {
        fold_expr_block(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_box(&mut self, i: ExprBox) -> ExprBox {
        fold_expr_box(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_break(&mut self, i: ExprBreak) -> ExprBreak {
        fold_expr_break(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_expr_call(&mut self, i: ExprCall) -> ExprCall {
        fold_expr_call(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_expr_cast(&mut self, i: ExprCast) -> ExprCast {
        fold_expr_cast(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_closure(&mut self, i: ExprClosure) -> ExprClosure {
        fold_expr_closure(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_continue(&mut self, i: ExprContinue) -> ExprContinue {
        fold_expr_continue(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_expr_field(&mut self, i: ExprField) -> ExprField {
        fold_expr_field(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_for_loop(&mut self, i: ExprForLoop) -> ExprForLoop {
        fold_expr_for_loop(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_group(&mut self, i: ExprGroup) -> ExprGroup {
        fold_expr_group(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_if(&mut self, i: ExprIf) -> ExprIf {
        fold_expr_if(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_in_place(&mut self, i: ExprInPlace) -> ExprInPlace {
        fold_expr_in_place(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_expr_index(&mut self, i: ExprIndex) -> ExprIndex {
        fold_expr_index(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_let(&mut self, i: ExprLet) -> ExprLet {
        fold_expr_let(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_expr_lit(&mut self, i: ExprLit) -> ExprLit {
        fold_expr_lit(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_loop(&mut self, i: ExprLoop) -> ExprLoop {
        fold_expr_loop(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_macro(&mut self, i: ExprMacro) -> ExprMacro {
        fold_expr_macro(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_match(&mut self, i: ExprMatch) -> ExprMatch {
        fold_expr_match(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_method_call(&mut self, i: ExprMethodCall) -> ExprMethodCall {
        fold_expr_method_call(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_expr_paren(&mut self, i: ExprParen) -> ExprParen {
        fold_expr_paren(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_expr_path(&mut self, i: ExprPath) -> ExprPath {
        fold_expr_path(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_range(&mut self, i: ExprRange) -> ExprRange {
        fold_expr_range(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_reference(&mut self, i: ExprReference) -> ExprReference {
        fold_expr_reference(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_repeat(&mut self, i: ExprRepeat) -> ExprRepeat {
        fold_expr_repeat(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_return(&mut self, i: ExprReturn) -> ExprReturn {
        fold_expr_return(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_struct(&mut self, i: ExprStruct) -> ExprStruct {
        fold_expr_struct(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_try(&mut self, i: ExprTry) -> ExprTry {
        fold_expr_try(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_try_block(&mut self, i: ExprTryBlock) -> ExprTryBlock {
        fold_expr_try_block(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_tuple(&mut self, i: ExprTuple) -> ExprTuple {
        fold_expr_tuple(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_type(&mut self, i: ExprType) -> ExprType {
        fold_expr_type(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_expr_unary(&mut self, i: ExprUnary) -> ExprUnary {
        fold_expr_unary(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_unsafe(&mut self, i: ExprUnsafe) -> ExprUnsafe {
        fold_expr_unsafe(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_expr_verbatim(&mut self, i: ExprVerbatim) -> ExprVerbatim {
        fold_expr_verbatim(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_while(&mut self, i: ExprWhile) -> ExprWhile {
        fold_expr_while(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_expr_yield(&mut self, i: ExprYield) -> ExprYield {
        fold_expr_yield(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_field(&mut self, i: Field) -> Field {
        fold_field(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_field_pat(&mut self, i: FieldPat) -> FieldPat {
        fold_field_pat(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_field_value(&mut self, i: FieldValue) -> FieldValue {
        fold_field_value(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_fields(&mut self, i: Fields) -> Fields {
        fold_fields(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_fields_named(&mut self, i: FieldsNamed) -> FieldsNamed {
        fold_fields_named(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_fields_unnamed(&mut self, i: FieldsUnnamed) -> FieldsUnnamed {
        fold_fields_unnamed(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_file(&mut self, i: File) -> File {
        fold_file(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_fn_arg(&mut self, i: FnArg) -> FnArg {
        fold_fn_arg(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_fn_decl(&mut self, i: FnDecl) -> FnDecl {
        fold_fn_decl(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_foreign_item(&mut self, i: ForeignItem) -> ForeignItem {
        fold_foreign_item(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_foreign_item_fn(&mut self, i: ForeignItemFn) -> ForeignItemFn {
        fold_foreign_item_fn(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_foreign_item_macro(&mut self, i: ForeignItemMacro) -> ForeignItemMacro {
        fold_foreign_item_macro(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_foreign_item_static(&mut self, i: ForeignItemStatic) -> ForeignItemStatic {
        fold_foreign_item_static(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_foreign_item_type(&mut self, i: ForeignItemType) -> ForeignItemType {
        fold_foreign_item_type(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_foreign_item_verbatim(&mut self, i: ForeignItemVerbatim) -> ForeignItemVerbatim {
        fold_foreign_item_verbatim(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_generic_argument(&mut self, i: GenericArgument) -> GenericArgument {
        fold_generic_argument(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_generic_method_argument(&mut self, i: GenericMethodArgument) -> GenericMethodArgument {
        fold_generic_method_argument(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_generic_param(&mut self, i: GenericParam) -> GenericParam {
        fold_generic_param(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_generics(&mut self, i: Generics) -> Generics {
        fold_generics(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_impl_item(&mut self, i: ImplItem) -> ImplItem {
        fold_impl_item(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_impl_item_const(&mut self, i: ImplItemConst) -> ImplItemConst {
        fold_impl_item_const(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_impl_item_existential(&mut self, i: ImplItemExistential) -> ImplItemExistential {
        fold_impl_item_existential(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_impl_item_macro(&mut self, i: ImplItemMacro) -> ImplItemMacro {
        fold_impl_item_macro(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_impl_item_method(&mut self, i: ImplItemMethod) -> ImplItemMethod {
        fold_impl_item_method(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_impl_item_type(&mut self, i: ImplItemType) -> ImplItemType {
        fold_impl_item_type(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_impl_item_verbatim(&mut self, i: ImplItemVerbatim) -> ImplItemVerbatim {
        fold_impl_item_verbatim(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_index(&mut self, i: Index) -> Index {
        fold_index(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item(&mut self, i: Item) -> Item {
        fold_item(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_const(&mut self, i: ItemConst) -> ItemConst {
        fold_item_const(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_enum(&mut self, i: ItemEnum) -> ItemEnum {
        fold_item_enum(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_existential(&mut self, i: ItemExistential) -> ItemExistential {
        fold_item_existential(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_extern_crate(&mut self, i: ItemExternCrate) -> ItemExternCrate {
        fold_item_extern_crate(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_fn(&mut self, i: ItemFn) -> ItemFn {
        fold_item_fn(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_foreign_mod(&mut self, i: ItemForeignMod) -> ItemForeignMod {
        fold_item_foreign_mod(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_impl(&mut self, i: ItemImpl) -> ItemImpl {
        fold_item_impl(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_macro(&mut self, i: ItemMacro) -> ItemMacro {
        fold_item_macro(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_macro2(&mut self, i: ItemMacro2) -> ItemMacro2 {
        fold_item_macro2(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_mod(&mut self, i: ItemMod) -> ItemMod {
        fold_item_mod(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_static(&mut self, i: ItemStatic) -> ItemStatic {
        fold_item_static(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_struct(&mut self, i: ItemStruct) -> ItemStruct {
        fold_item_struct(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_trait(&mut self, i: ItemTrait) -> ItemTrait {
        fold_item_trait(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_trait_alias(&mut self, i: ItemTraitAlias) -> ItemTraitAlias {
        fold_item_trait_alias(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_type(&mut self, i: ItemType) -> ItemType {
        fold_item_type(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_union(&mut self, i: ItemUnion) -> ItemUnion {
        fold_item_union(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_use(&mut self, i: ItemUse) -> ItemUse {
        fold_item_use(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_item_verbatim(&mut self, i: ItemVerbatim) -> ItemVerbatim {
        fold_item_verbatim(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_label(&mut self, i: Label) -> Label {
        fold_label(self, i)
    }
    fn fold_lifetime(&mut self, i: Lifetime) -> Lifetime {
        fold_lifetime(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_lifetime_def(&mut self, i: LifetimeDef) -> LifetimeDef {
        fold_lifetime_def(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_lit(&mut self, i: Lit) -> Lit {
        fold_lit(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_lit_bool(&mut self, i: LitBool) -> LitBool {
        fold_lit_bool(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_lit_byte(&mut self, i: LitByte) -> LitByte {
        fold_lit_byte(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_lit_byte_str(&mut self, i: LitByteStr) -> LitByteStr {
        fold_lit_byte_str(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_lit_char(&mut self, i: LitChar) -> LitChar {
        fold_lit_char(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_lit_float(&mut self, i: LitFloat) -> LitFloat {
        fold_lit_float(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_lit_int(&mut self, i: LitInt) -> LitInt {
        fold_lit_int(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_lit_str(&mut self, i: LitStr) -> LitStr {
        fold_lit_str(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_lit_verbatim(&mut self, i: LitVerbatim) -> LitVerbatim {
        fold_lit_verbatim(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_local(&mut self, i: Local) -> Local {
        fold_local(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_macro(&mut self, i: Macro) -> Macro {
        fold_macro(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_macro_delimiter(&mut self, i: MacroDelimiter) -> MacroDelimiter {
        fold_macro_delimiter(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_member(&mut self, i: Member) -> Member {
        fold_member(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_meta(&mut self, i: Meta) -> Meta {
        fold_meta(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_meta_list(&mut self, i: MetaList) -> MetaList {
        fold_meta_list(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_meta_name_value(&mut self, i: MetaNameValue) -> MetaNameValue {
        fold_meta_name_value(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_method_sig(&mut self, i: MethodSig) -> MethodSig {
        fold_method_sig(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_method_turbofish(&mut self, i: MethodTurbofish) -> MethodTurbofish {
        fold_method_turbofish(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_nested_meta(&mut self, i: NestedMeta) -> NestedMeta {
        fold_nested_meta(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_parenthesized_generic_arguments(
        &mut self,
        i: ParenthesizedGenericArguments,
    ) -> ParenthesizedGenericArguments {
        fold_parenthesized_generic_arguments(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat(&mut self, i: Pat) -> Pat {
        fold_pat(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_box(&mut self, i: PatBox) -> PatBox {
        fold_pat_box(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_ident(&mut self, i: PatIdent) -> PatIdent {
        fold_pat_ident(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_lit(&mut self, i: PatLit) -> PatLit {
        fold_pat_lit(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_macro(&mut self, i: PatMacro) -> PatMacro {
        fold_pat_macro(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_path(&mut self, i: PatPath) -> PatPath {
        fold_pat_path(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_range(&mut self, i: PatRange) -> PatRange {
        fold_pat_range(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_ref(&mut self, i: PatRef) -> PatRef {
        fold_pat_ref(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_slice(&mut self, i: PatSlice) -> PatSlice {
        fold_pat_slice(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_struct(&mut self, i: PatStruct) -> PatStruct {
        fold_pat_struct(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_tuple(&mut self, i: PatTuple) -> PatTuple {
        fold_pat_tuple(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_tuple_struct(&mut self, i: PatTupleStruct) -> PatTupleStruct {
        fold_pat_tuple_struct(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_verbatim(&mut self, i: PatVerbatim) -> PatVerbatim {
        fold_pat_verbatim(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_pat_wild(&mut self, i: PatWild) -> PatWild {
        fold_pat_wild(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_path(&mut self, i: Path) -> Path {
        fold_path(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_path_arguments(&mut self, i: PathArguments) -> PathArguments {
        fold_path_arguments(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_path_segment(&mut self, i: PathSegment) -> PathSegment {
        fold_path_segment(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_predicate_eq(&mut self, i: PredicateEq) -> PredicateEq {
        fold_predicate_eq(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_predicate_lifetime(&mut self, i: PredicateLifetime) -> PredicateLifetime {
        fold_predicate_lifetime(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_predicate_type(&mut self, i: PredicateType) -> PredicateType {
        fold_predicate_type(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_qself(&mut self, i: QSelf) -> QSelf {
        fold_qself(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_range_limits(&mut self, i: RangeLimits) -> RangeLimits {
        fold_range_limits(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_return_type(&mut self, i: ReturnType) -> ReturnType {
        fold_return_type(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_stmt(&mut self, i: Stmt) -> Stmt {
        fold_stmt(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_trait_bound(&mut self, i: TraitBound) -> TraitBound {
        fold_trait_bound(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_trait_bound_modifier(&mut self, i: TraitBoundModifier) -> TraitBoundModifier {
        fold_trait_bound_modifier(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_trait_item(&mut self, i: TraitItem) -> TraitItem {
        fold_trait_item(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_trait_item_const(&mut self, i: TraitItemConst) -> TraitItemConst {
        fold_trait_item_const(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_trait_item_macro(&mut self, i: TraitItemMacro) -> TraitItemMacro {
        fold_trait_item_macro(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_trait_item_method(&mut self, i: TraitItemMethod) -> TraitItemMethod {
        fold_trait_item_method(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_trait_item_type(&mut self, i: TraitItemType) -> TraitItemType {
        fold_trait_item_type(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_trait_item_verbatim(&mut self, i: TraitItemVerbatim) -> TraitItemVerbatim {
        fold_trait_item_verbatim(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type(&mut self, i: Type) -> Type {
        fold_type(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_array(&mut self, i: TypeArray) -> TypeArray {
        fold_type_array(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_bare_fn(&mut self, i: TypeBareFn) -> TypeBareFn {
        fold_type_bare_fn(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_group(&mut self, i: TypeGroup) -> TypeGroup {
        fold_type_group(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_impl_trait(&mut self, i: TypeImplTrait) -> TypeImplTrait {
        fold_type_impl_trait(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_infer(&mut self, i: TypeInfer) -> TypeInfer {
        fold_type_infer(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_macro(&mut self, i: TypeMacro) -> TypeMacro {
        fold_type_macro(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_never(&mut self, i: TypeNever) -> TypeNever {
        fold_type_never(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_param(&mut self, i: TypeParam) -> TypeParam {
        fold_type_param(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_param_bound(&mut self, i: TypeParamBound) -> TypeParamBound {
        fold_type_param_bound(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_paren(&mut self, i: TypeParen) -> TypeParen {
        fold_type_paren(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_path(&mut self, i: TypePath) -> TypePath {
        fold_type_path(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_ptr(&mut self, i: TypePtr) -> TypePtr {
        fold_type_ptr(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_reference(&mut self, i: TypeReference) -> TypeReference {
        fold_type_reference(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_slice(&mut self, i: TypeSlice) -> TypeSlice {
        fold_type_slice(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_trait_object(&mut self, i: TypeTraitObject) -> TypeTraitObject {
        fold_type_trait_object(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_tuple(&mut self, i: TypeTuple) -> TypeTuple {
        fold_type_tuple(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_type_verbatim(&mut self, i: TypeVerbatim) -> TypeVerbatim {
        fold_type_verbatim(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_un_op(&mut self, i: UnOp) -> UnOp {
        fold_un_op(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_use_glob(&mut self, i: UseGlob) -> UseGlob {
        fold_use_glob(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_use_group(&mut self, i: UseGroup) -> UseGroup {
        fold_use_group(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_use_name(&mut self, i: UseName) -> UseName {
        fold_use_name(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_use_path(&mut self, i: UsePath) -> UsePath {
        fold_use_path(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_use_rename(&mut self, i: UseRename) -> UseRename {
        fold_use_rename(self, i)
    }
    #[cfg(feature = "full")]
    fn fold_use_tree(&mut self, i: UseTree) -> UseTree {
        fold_use_tree(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_variant(&mut self, i: Variant) -> Variant {
        fold_variant(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_vis_crate(&mut self, i: VisCrate) -> VisCrate {
        fold_vis_crate(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_vis_public(&mut self, i: VisPublic) -> VisPublic {
        fold_vis_public(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_vis_restricted(&mut self, i: VisRestricted) -> VisRestricted {
        fold_vis_restricted(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_visibility(&mut self, i: Visibility) -> Visibility {
        fold_visibility(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_where_clause(&mut self, i: WhereClause) -> WhereClause {
        fold_where_clause(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn fold_where_predicate(&mut self, i: WherePredicate) -> WherePredicate {
        fold_where_predicate(self, i)
    }
    fn fold_span(&mut self, i: Span) -> Span {
        fold_span(self, i)
    }
    fn fold_ident(&mut self, i: Ident) -> Ident {
        fold_ident(self, i)
    }
}
#[cfg(any(feature = "full", feature = "derive"))]
macro_rules! fold_span_only {
    ($f:ident : $t:ident) => {
        pub fn $f<V: Fold + ?Sized>(_visitor: &mut V, mut _i: $t) -> $t {
            let span = _visitor.fold_span(_i.span());
            _i.set_span(span);
            _i
        }
    };
}
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lit_byte: LitByte);
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lit_byte_str: LitByteStr);
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lit_char: LitChar);
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lit_float: LitFloat);
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lit_int: LitInt);
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lit_str: LitStr);
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_abi<V: Fold + ?Sized>(_visitor: &mut V, _i: Abi) -> Abi {
    Abi {
        extern_token: Token![extern](tokens_helper(_visitor, &_i.extern_token.span)),
        name: (_i.name).map(|it| _visitor.fold_lit_str(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_angle_bracketed_generic_arguments<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: AngleBracketedGenericArguments,
) -> AngleBracketedGenericArguments {
    AngleBracketedGenericArguments {
        colon2_token: (_i.colon2_token)
            .map(|it| Token ! [ :: ](tokens_helper(_visitor, &it.spans))),
        lt_token: Token ! [ < ](tokens_helper(_visitor, &_i.lt_token.spans)),
        args: FoldHelper::lift(_i.args, |it| _visitor.fold_generic_argument(it)),
        gt_token: Token ! [ > ](tokens_helper(_visitor, &_i.gt_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_arg_captured<V: Fold + ?Sized>(_visitor: &mut V, _i: ArgCaptured) -> ArgCaptured {
    ArgCaptured {
        pat: _visitor.fold_pat(_i.pat),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &_i.colon_token.spans)),
        ty: _visitor.fold_type(_i.ty),
    }
}
#[cfg(feature = "full")]
pub fn fold_arg_self<V: Fold + ?Sized>(_visitor: &mut V, _i: ArgSelf) -> ArgSelf {
    ArgSelf {
        mutability: (_i.mutability).map(|it| Token![mut](tokens_helper(_visitor, &it.span))),
        self_token: Token![self](tokens_helper(_visitor, &_i.self_token.span)),
    }
}
#[cfg(feature = "full")]
pub fn fold_arg_self_ref<V: Fold + ?Sized>(_visitor: &mut V, _i: ArgSelfRef) -> ArgSelfRef {
    ArgSelfRef {
        and_token: Token ! [ & ](tokens_helper(_visitor, &_i.and_token.spans)),
        lifetime: (_i.lifetime).map(|it| _visitor.fold_lifetime(it)),
        mutability: (_i.mutability).map(|it| Token![mut](tokens_helper(_visitor, &it.span))),
        self_token: Token![self](tokens_helper(_visitor, &_i.self_token.span)),
    }
}
#[cfg(feature = "full")]
pub fn fold_arm<V: Fold + ?Sized>(_visitor: &mut V, _i: Arm) -> Arm {
    Arm {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        leading_vert: (_i.leading_vert).map(|it| Token ! [ | ](tokens_helper(_visitor, &it.spans))),
        pats: FoldHelper::lift(_i.pats, |it| _visitor.fold_pat(it)),
        guard: (_i.guard).map(|it| {
            (
                Token![if](tokens_helper(_visitor, &(it).0.span)),
                Box::new(_visitor.fold_expr(*(it).1)),
            )
        }),
        fat_arrow_token: Token ! [ => ](tokens_helper(_visitor, &_i.fat_arrow_token.spans)),
        body: Box::new(_visitor.fold_expr(*_i.body)),
        comma: (_i.comma).map(|it| Token ! [ , ](tokens_helper(_visitor, &it.spans))),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_attr_style<V: Fold + ?Sized>(_visitor: &mut V, _i: AttrStyle) -> AttrStyle {
    match _i {
        AttrStyle::Outer => AttrStyle::Outer,
        AttrStyle::Inner(_binding_0) => {
            AttrStyle::Inner(Token![!](tokens_helper(_visitor, &_binding_0.spans)))
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_attribute<V: Fold + ?Sized>(_visitor: &mut V, _i: Attribute) -> Attribute {
    Attribute {
        pound_token: Token ! [ # ](tokens_helper(_visitor, &_i.pound_token.spans)),
        style: _visitor.fold_attr_style(_i.style),
        bracket_token: Bracket(tokens_helper(_visitor, &_i.bracket_token.span)),
        path: _visitor.fold_path(_i.path),
        tts: _i.tts,
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_bare_fn_arg<V: Fold + ?Sized>(_visitor: &mut V, _i: BareFnArg) -> BareFnArg {
    BareFnArg {
        name: (_i.name).map(|it| {
            (
                _visitor.fold_bare_fn_arg_name((it).0),
                Token ! [ : ](tokens_helper(_visitor, &(it).1.spans)),
            )
        }),
        ty: _visitor.fold_type(_i.ty),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_bare_fn_arg_name<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: BareFnArgName,
) -> BareFnArgName {
    match _i {
        BareFnArgName::Named(_binding_0) => BareFnArgName::Named(_visitor.fold_ident(_binding_0)),
        BareFnArgName::Wild(_binding_0) => {
            BareFnArgName::Wild(Token![_](tokens_helper(_visitor, &_binding_0.spans)))
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_bin_op<V: Fold + ?Sized>(_visitor: &mut V, _i: BinOp) -> BinOp {
    match _i {
        BinOp::Add(_binding_0) => {
            BinOp::Add(Token ! [ + ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Sub(_binding_0) => {
            BinOp::Sub(Token ! [ - ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Mul(_binding_0) => {
            BinOp::Mul(Token ! [ * ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Div(_binding_0) => {
            BinOp::Div(Token ! [ / ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Rem(_binding_0) => {
            BinOp::Rem(Token ! [ % ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::And(_binding_0) => {
            BinOp::And(Token ! [ && ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Or(_binding_0) => {
            BinOp::Or(Token ! [ || ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::BitXor(_binding_0) => {
            BinOp::BitXor(Token ! [ ^ ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::BitAnd(_binding_0) => {
            BinOp::BitAnd(Token ! [ & ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::BitOr(_binding_0) => {
            BinOp::BitOr(Token ! [ | ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Shl(_binding_0) => {
            BinOp::Shl(Token ! [ << ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Shr(_binding_0) => {
            BinOp::Shr(Token ! [ >> ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Eq(_binding_0) => {
            BinOp::Eq(Token ! [ == ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Lt(_binding_0) => {
            BinOp::Lt(Token ! [ < ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Le(_binding_0) => {
            BinOp::Le(Token ! [ <= ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Ne(_binding_0) => {
            BinOp::Ne(Token ! [ != ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Ge(_binding_0) => {
            BinOp::Ge(Token ! [ >= ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::Gt(_binding_0) => {
            BinOp::Gt(Token ! [ > ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::AddEq(_binding_0) => {
            BinOp::AddEq(Token ! [ += ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::SubEq(_binding_0) => {
            BinOp::SubEq(Token ! [ -= ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::MulEq(_binding_0) => {
            BinOp::MulEq(Token ! [ *= ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::DivEq(_binding_0) => {
            BinOp::DivEq(Token ! [ /= ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::RemEq(_binding_0) => {
            BinOp::RemEq(Token ! [ %= ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::BitXorEq(_binding_0) => {
            BinOp::BitXorEq(Token ! [ ^= ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::BitAndEq(_binding_0) => {
            BinOp::BitAndEq(Token ! [ &= ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::BitOrEq(_binding_0) => {
            BinOp::BitOrEq(Token ! [ |= ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::ShlEq(_binding_0) => {
            BinOp::ShlEq(Token ! [ <<= ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        BinOp::ShrEq(_binding_0) => {
            BinOp::ShrEq(Token ! [ >>= ](tokens_helper(_visitor, &_binding_0.spans)))
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_binding<V: Fold + ?Sized>(_visitor: &mut V, _i: Binding) -> Binding {
    Binding {
        ident: _visitor.fold_ident(_i.ident),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &_i.eq_token.spans)),
        ty: _visitor.fold_type(_i.ty),
    }
}
#[cfg(feature = "full")]
pub fn fold_block<V: Fold + ?Sized>(_visitor: &mut V, _i: Block) -> Block {
    Block {
        brace_token: Brace(tokens_helper(_visitor, &_i.brace_token.span)),
        stmts: FoldHelper::lift(_i.stmts, |it| _visitor.fold_stmt(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_bound_lifetimes<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: BoundLifetimes,
) -> BoundLifetimes {
    BoundLifetimes {
        for_token: Token![for](tokens_helper(_visitor, &_i.for_token.span)),
        lt_token: Token ! [ < ](tokens_helper(_visitor, &_i.lt_token.spans)),
        lifetimes: FoldHelper::lift(_i.lifetimes, |it| _visitor.fold_lifetime_def(it)),
        gt_token: Token ! [ > ](tokens_helper(_visitor, &_i.gt_token.spans)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_const_param<V: Fold + ?Sized>(_visitor: &mut V, _i: ConstParam) -> ConstParam {
    ConstParam {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        const_token: Token![const](tokens_helper(_visitor, &_i.const_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &_i.colon_token.spans)),
        ty: _visitor.fold_type(_i.ty),
        eq_token: (_i.eq_token).map(|it| Token ! [ = ](tokens_helper(_visitor, &it.spans))),
        default: (_i.default).map(|it| _visitor.fold_expr(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_constraint<V: Fold + ?Sized>(_visitor: &mut V, _i: Constraint) -> Constraint {
    Constraint {
        ident: _visitor.fold_ident(_i.ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &_i.colon_token.spans)),
        bounds: FoldHelper::lift(_i.bounds, |it| _visitor.fold_type_param_bound(it)),
    }
}
#[cfg(feature = "derive")]
pub fn fold_data<V: Fold + ?Sized>(_visitor: &mut V, _i: Data) -> Data {
    match _i {
        Data::Struct(_binding_0) => Data::Struct(_visitor.fold_data_struct(_binding_0)),
        Data::Enum(_binding_0) => Data::Enum(_visitor.fold_data_enum(_binding_0)),
        Data::Union(_binding_0) => Data::Union(_visitor.fold_data_union(_binding_0)),
    }
}
#[cfg(feature = "derive")]
pub fn fold_data_enum<V: Fold + ?Sized>(_visitor: &mut V, _i: DataEnum) -> DataEnum {
    DataEnum {
        enum_token: Token![enum](tokens_helper(_visitor, &_i.enum_token.span)),
        brace_token: Brace(tokens_helper(_visitor, &_i.brace_token.span)),
        variants: FoldHelper::lift(_i.variants, |it| _visitor.fold_variant(it)),
    }
}
#[cfg(feature = "derive")]
pub fn fold_data_struct<V: Fold + ?Sized>(_visitor: &mut V, _i: DataStruct) -> DataStruct {
    DataStruct {
        struct_token: Token![struct](tokens_helper(_visitor, &_i.struct_token.span)),
        fields: _visitor.fold_fields(_i.fields),
        semi_token: (_i.semi_token).map(|it| Token ! [ ; ](tokens_helper(_visitor, &it.spans))),
    }
}
#[cfg(feature = "derive")]
pub fn fold_data_union<V: Fold + ?Sized>(_visitor: &mut V, _i: DataUnion) -> DataUnion {
    DataUnion {
        union_token: Token![union](tokens_helper(_visitor, &_i.union_token.span)),
        fields: _visitor.fold_fields_named(_i.fields),
    }
}
#[cfg(feature = "derive")]
pub fn fold_derive_input<V: Fold + ?Sized>(_visitor: &mut V, _i: DeriveInput) -> DeriveInput {
    DeriveInput {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        ident: _visitor.fold_ident(_i.ident),
        generics: _visitor.fold_generics(_i.generics),
        data: _visitor.fold_data(_i.data),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_expr<V: Fold + ?Sized>(_visitor: &mut V, _i: Expr) -> Expr {
    match _i {
        Expr::Box(_binding_0) => Expr::Box(full!(_visitor.fold_expr_box(_binding_0))),
        Expr::InPlace(_binding_0) => Expr::InPlace(full!(_visitor.fold_expr_in_place(_binding_0))),
        Expr::Array(_binding_0) => Expr::Array(full!(_visitor.fold_expr_array(_binding_0))),
        Expr::Call(_binding_0) => Expr::Call(_visitor.fold_expr_call(_binding_0)),
        Expr::MethodCall(_binding_0) => {
            Expr::MethodCall(full!(_visitor.fold_expr_method_call(_binding_0)))
        }
        Expr::Tuple(_binding_0) => Expr::Tuple(full!(_visitor.fold_expr_tuple(_binding_0))),
        Expr::Binary(_binding_0) => Expr::Binary(_visitor.fold_expr_binary(_binding_0)),
        Expr::Unary(_binding_0) => Expr::Unary(_visitor.fold_expr_unary(_binding_0)),
        Expr::Lit(_binding_0) => Expr::Lit(_visitor.fold_expr_lit(_binding_0)),
        Expr::Cast(_binding_0) => Expr::Cast(_visitor.fold_expr_cast(_binding_0)),
        Expr::Type(_binding_0) => Expr::Type(full!(_visitor.fold_expr_type(_binding_0))),
        Expr::Let(_binding_0) => Expr::Let(full!(_visitor.fold_expr_let(_binding_0))),
        Expr::If(_binding_0) => Expr::If(full!(_visitor.fold_expr_if(_binding_0))),
        Expr::While(_binding_0) => Expr::While(full!(_visitor.fold_expr_while(_binding_0))),
        Expr::ForLoop(_binding_0) => Expr::ForLoop(full!(_visitor.fold_expr_for_loop(_binding_0))),
        Expr::Loop(_binding_0) => Expr::Loop(full!(_visitor.fold_expr_loop(_binding_0))),
        Expr::Match(_binding_0) => Expr::Match(full!(_visitor.fold_expr_match(_binding_0))),
        Expr::Closure(_binding_0) => Expr::Closure(full!(_visitor.fold_expr_closure(_binding_0))),
        Expr::Unsafe(_binding_0) => Expr::Unsafe(full!(_visitor.fold_expr_unsafe(_binding_0))),
        Expr::Block(_binding_0) => Expr::Block(full!(_visitor.fold_expr_block(_binding_0))),
        Expr::Assign(_binding_0) => Expr::Assign(full!(_visitor.fold_expr_assign(_binding_0))),
        Expr::AssignOp(_binding_0) => {
            Expr::AssignOp(full!(_visitor.fold_expr_assign_op(_binding_0)))
        }
        Expr::Field(_binding_0) => Expr::Field(_visitor.fold_expr_field(_binding_0)),
        Expr::Index(_binding_0) => Expr::Index(_visitor.fold_expr_index(_binding_0)),
        Expr::Range(_binding_0) => Expr::Range(full!(_visitor.fold_expr_range(_binding_0))),
        Expr::Path(_binding_0) => Expr::Path(_visitor.fold_expr_path(_binding_0)),
        Expr::Reference(_binding_0) => {
            Expr::Reference(full!(_visitor.fold_expr_reference(_binding_0)))
        }
        Expr::Break(_binding_0) => Expr::Break(full!(_visitor.fold_expr_break(_binding_0))),
        Expr::Continue(_binding_0) => {
            Expr::Continue(full!(_visitor.fold_expr_continue(_binding_0)))
        }
        Expr::Return(_binding_0) => Expr::Return(full!(_visitor.fold_expr_return(_binding_0))),
        Expr::Macro(_binding_0) => Expr::Macro(full!(_visitor.fold_expr_macro(_binding_0))),
        Expr::Struct(_binding_0) => Expr::Struct(full!(_visitor.fold_expr_struct(_binding_0))),
        Expr::Repeat(_binding_0) => Expr::Repeat(full!(_visitor.fold_expr_repeat(_binding_0))),
        Expr::Paren(_binding_0) => Expr::Paren(_visitor.fold_expr_paren(_binding_0)),
        Expr::Group(_binding_0) => Expr::Group(full!(_visitor.fold_expr_group(_binding_0))),
        Expr::Try(_binding_0) => Expr::Try(full!(_visitor.fold_expr_try(_binding_0))),
        Expr::Async(_binding_0) => Expr::Async(full!(_visitor.fold_expr_async(_binding_0))),
        Expr::TryBlock(_binding_0) => {
            Expr::TryBlock(full!(_visitor.fold_expr_try_block(_binding_0)))
        }
        Expr::Yield(_binding_0) => Expr::Yield(full!(_visitor.fold_expr_yield(_binding_0))),
        Expr::Verbatim(_binding_0) => Expr::Verbatim(_visitor.fold_expr_verbatim(_binding_0)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_array<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprArray) -> ExprArray {
    ExprArray {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        bracket_token: Bracket(tokens_helper(_visitor, &_i.bracket_token.span)),
        elems: FoldHelper::lift(_i.elems, |it| _visitor.fold_expr(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_assign<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprAssign) -> ExprAssign {
    ExprAssign {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        left: Box::new(_visitor.fold_expr(*_i.left)),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &_i.eq_token.spans)),
        right: Box::new(_visitor.fold_expr(*_i.right)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_assign_op<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprAssignOp) -> ExprAssignOp {
    ExprAssignOp {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        left: Box::new(_visitor.fold_expr(*_i.left)),
        op: _visitor.fold_bin_op(_i.op),
        right: Box::new(_visitor.fold_expr(*_i.right)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_async<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprAsync) -> ExprAsync {
    ExprAsync {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        async_token: Token![async](tokens_helper(_visitor, &_i.async_token.span)),
        capture: (_i.capture).map(|it| Token![move](tokens_helper(_visitor, &it.span))),
        block: _visitor.fold_block(_i.block),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_expr_binary<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprBinary) -> ExprBinary {
    ExprBinary {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        left: Box::new(_visitor.fold_expr(*_i.left)),
        op: _visitor.fold_bin_op(_i.op),
        right: Box::new(_visitor.fold_expr(*_i.right)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_block<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprBlock) -> ExprBlock {
    ExprBlock {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        label: (_i.label).map(|it| _visitor.fold_label(it)),
        block: _visitor.fold_block(_i.block),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_box<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprBox) -> ExprBox {
    ExprBox {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        box_token: Token![box](tokens_helper(_visitor, &_i.box_token.span)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_break<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprBreak) -> ExprBreak {
    ExprBreak {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        break_token: Token![break](tokens_helper(_visitor, &_i.break_token.span)),
        label: (_i.label).map(|it| _visitor.fold_lifetime(it)),
        expr: (_i.expr).map(|it| Box::new(_visitor.fold_expr(*it))),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_expr_call<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprCall) -> ExprCall {
    ExprCall {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        func: Box::new(_visitor.fold_expr(*_i.func)),
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        args: FoldHelper::lift(_i.args, |it| _visitor.fold_expr(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_expr_cast<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprCast) -> ExprCast {
    ExprCast {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
        as_token: Token![as](tokens_helper(_visitor, &_i.as_token.span)),
        ty: Box::new(_visitor.fold_type(*_i.ty)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_closure<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprClosure) -> ExprClosure {
    ExprClosure {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        asyncness: (_i.asyncness).map(|it| Token![async](tokens_helper(_visitor, &it.span))),
        movability: (_i.movability).map(|it| Token![static](tokens_helper(_visitor, &it.span))),
        capture: (_i.capture).map(|it| Token![move](tokens_helper(_visitor, &it.span))),
        or1_token: Token ! [ | ](tokens_helper(_visitor, &_i.or1_token.spans)),
        inputs: FoldHelper::lift(_i.inputs, |it| _visitor.fold_fn_arg(it)),
        or2_token: Token ! [ | ](tokens_helper(_visitor, &_i.or2_token.spans)),
        output: _visitor.fold_return_type(_i.output),
        body: Box::new(_visitor.fold_expr(*_i.body)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_continue<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprContinue) -> ExprContinue {
    ExprContinue {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        continue_token: Token![continue](tokens_helper(_visitor, &_i.continue_token.span)),
        label: (_i.label).map(|it| _visitor.fold_lifetime(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_expr_field<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprField) -> ExprField {
    ExprField {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        base: Box::new(_visitor.fold_expr(*_i.base)),
        dot_token: Token ! [ . ](tokens_helper(_visitor, &_i.dot_token.spans)),
        member: _visitor.fold_member(_i.member),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_for_loop<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprForLoop) -> ExprForLoop {
    ExprForLoop {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        label: (_i.label).map(|it| _visitor.fold_label(it)),
        for_token: Token![for](tokens_helper(_visitor, &_i.for_token.span)),
        pat: Box::new(_visitor.fold_pat(*_i.pat)),
        in_token: Token![in](tokens_helper(_visitor, &_i.in_token.span)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
        body: _visitor.fold_block(_i.body),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_group<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprGroup) -> ExprGroup {
    ExprGroup {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        group_token: Group(tokens_helper(_visitor, &_i.group_token.span)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_if<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprIf) -> ExprIf {
    ExprIf {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        if_token: Token![if](tokens_helper(_visitor, &_i.if_token.span)),
        cond: Box::new(_visitor.fold_expr(*_i.cond)),
        then_branch: _visitor.fold_block(_i.then_branch),
        else_branch: (_i.else_branch).map(|it| {
            (
                Token![else](tokens_helper(_visitor, &(it).0.span)),
                Box::new(_visitor.fold_expr(*(it).1)),
            )
        }),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_in_place<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprInPlace) -> ExprInPlace {
    ExprInPlace {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        place: Box::new(_visitor.fold_expr(*_i.place)),
        arrow_token: Token ! [ <- ](tokens_helper(_visitor, &_i.arrow_token.spans)),
        value: Box::new(_visitor.fold_expr(*_i.value)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_expr_index<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprIndex) -> ExprIndex {
    ExprIndex {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
        bracket_token: Bracket(tokens_helper(_visitor, &_i.bracket_token.span)),
        index: Box::new(_visitor.fold_expr(*_i.index)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_let<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprLet) -> ExprLet {
    ExprLet {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        let_token: Token![let](tokens_helper(_visitor, &_i.let_token.span)),
        pats: FoldHelper::lift(_i.pats, |it| _visitor.fold_pat(it)),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &_i.eq_token.spans)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_expr_lit<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprLit) -> ExprLit {
    ExprLit {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        lit: _visitor.fold_lit(_i.lit),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_loop<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprLoop) -> ExprLoop {
    ExprLoop {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        label: (_i.label).map(|it| _visitor.fold_label(it)),
        loop_token: Token![loop](tokens_helper(_visitor, &_i.loop_token.span)),
        body: _visitor.fold_block(_i.body),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_macro<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprMacro) -> ExprMacro {
    ExprMacro {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        mac: _visitor.fold_macro(_i.mac),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_match<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprMatch) -> ExprMatch {
    ExprMatch {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        match_token: Token![match](tokens_helper(_visitor, &_i.match_token.span)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
        brace_token: Brace(tokens_helper(_visitor, &_i.brace_token.span)),
        arms: FoldHelper::lift(_i.arms, |it| _visitor.fold_arm(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_method_call<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ExprMethodCall,
) -> ExprMethodCall {
    ExprMethodCall {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        receiver: Box::new(_visitor.fold_expr(*_i.receiver)),
        dot_token: Token ! [ . ](tokens_helper(_visitor, &_i.dot_token.spans)),
        method: _visitor.fold_ident(_i.method),
        turbofish: (_i.turbofish).map(|it| _visitor.fold_method_turbofish(it)),
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        args: FoldHelper::lift(_i.args, |it| _visitor.fold_expr(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_expr_paren<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprParen) -> ExprParen {
    ExprParen {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_expr_path<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprPath) -> ExprPath {
    ExprPath {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        qself: (_i.qself).map(|it| _visitor.fold_qself(it)),
        path: _visitor.fold_path(_i.path),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_range<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprRange) -> ExprRange {
    ExprRange {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        from: (_i.from).map(|it| Box::new(_visitor.fold_expr(*it))),
        limits: _visitor.fold_range_limits(_i.limits),
        to: (_i.to).map(|it| Box::new(_visitor.fold_expr(*it))),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_reference<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprReference) -> ExprReference {
    ExprReference {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        and_token: Token ! [ & ](tokens_helper(_visitor, &_i.and_token.spans)),
        mutability: (_i.mutability).map(|it| Token![mut](tokens_helper(_visitor, &it.span))),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_repeat<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprRepeat) -> ExprRepeat {
    ExprRepeat {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        bracket_token: Bracket(tokens_helper(_visitor, &_i.bracket_token.span)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
        len: Box::new(_visitor.fold_expr(*_i.len)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_return<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprReturn) -> ExprReturn {
    ExprReturn {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        return_token: Token![return](tokens_helper(_visitor, &_i.return_token.span)),
        expr: (_i.expr).map(|it| Box::new(_visitor.fold_expr(*it))),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_struct<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprStruct) -> ExprStruct {
    ExprStruct {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        path: _visitor.fold_path(_i.path),
        brace_token: Brace(tokens_helper(_visitor, &_i.brace_token.span)),
        fields: FoldHelper::lift(_i.fields, |it| _visitor.fold_field_value(it)),
        dot2_token: (_i.dot2_token).map(|it| Token![..](tokens_helper(_visitor, &it.spans))),
        rest: (_i.rest).map(|it| Box::new(_visitor.fold_expr(*it))),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_try<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprTry) -> ExprTry {
    ExprTry {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
        question_token: Token ! [ ? ](tokens_helper(_visitor, &_i.question_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_try_block<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprTryBlock) -> ExprTryBlock {
    ExprTryBlock {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        try_token: Token![try](tokens_helper(_visitor, &_i.try_token.span)),
        block: _visitor.fold_block(_i.block),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_tuple<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprTuple) -> ExprTuple {
    ExprTuple {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        elems: FoldHelper::lift(_i.elems, |it| _visitor.fold_expr(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_type<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprType) -> ExprType {
    ExprType {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &_i.colon_token.spans)),
        ty: Box::new(_visitor.fold_type(*_i.ty)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_expr_unary<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprUnary) -> ExprUnary {
    ExprUnary {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        op: _visitor.fold_un_op(_i.op),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_unsafe<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprUnsafe) -> ExprUnsafe {
    ExprUnsafe {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        unsafe_token: Token![unsafe](tokens_helper(_visitor, &_i.unsafe_token.span)),
        block: _visitor.fold_block(_i.block),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_expr_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprVerbatim) -> ExprVerbatim {
    ExprVerbatim { tts: _i.tts }
}
#[cfg(feature = "full")]
pub fn fold_expr_while<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprWhile) -> ExprWhile {
    ExprWhile {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        label: (_i.label).map(|it| _visitor.fold_label(it)),
        while_token: Token![while](tokens_helper(_visitor, &_i.while_token.span)),
        cond: Box::new(_visitor.fold_expr(*_i.cond)),
        body: _visitor.fold_block(_i.body),
    }
}
#[cfg(feature = "full")]
pub fn fold_expr_yield<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprYield) -> ExprYield {
    ExprYield {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        yield_token: Token![yield](tokens_helper(_visitor, &_i.yield_token.span)),
        expr: (_i.expr).map(|it| Box::new(_visitor.fold_expr(*it))),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_field<V: Fold + ?Sized>(_visitor: &mut V, _i: Field) -> Field {
    Field {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        ident: (_i.ident).map(|it| _visitor.fold_ident(it)),
        colon_token: (_i.colon_token).map(|it| Token ! [ : ](tokens_helper(_visitor, &it.spans))),
        ty: _visitor.fold_type(_i.ty),
    }
}
#[cfg(feature = "full")]
pub fn fold_field_pat<V: Fold + ?Sized>(_visitor: &mut V, _i: FieldPat) -> FieldPat {
    FieldPat {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        member: _visitor.fold_member(_i.member),
        colon_token: (_i.colon_token).map(|it| Token ! [ : ](tokens_helper(_visitor, &it.spans))),
        pat: Box::new(_visitor.fold_pat(*_i.pat)),
    }
}
#[cfg(feature = "full")]
pub fn fold_field_value<V: Fold + ?Sized>(_visitor: &mut V, _i: FieldValue) -> FieldValue {
    FieldValue {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        member: _visitor.fold_member(_i.member),
        colon_token: (_i.colon_token).map(|it| Token ! [ : ](tokens_helper(_visitor, &it.spans))),
        expr: _visitor.fold_expr(_i.expr),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_fields<V: Fold + ?Sized>(_visitor: &mut V, _i: Fields) -> Fields {
    match _i {
        Fields::Named(_binding_0) => Fields::Named(_visitor.fold_fields_named(_binding_0)),
        Fields::Unnamed(_binding_0) => Fields::Unnamed(_visitor.fold_fields_unnamed(_binding_0)),
        Fields::Unit => Fields::Unit,
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_fields_named<V: Fold + ?Sized>(_visitor: &mut V, _i: FieldsNamed) -> FieldsNamed {
    FieldsNamed {
        brace_token: Brace(tokens_helper(_visitor, &_i.brace_token.span)),
        named: FoldHelper::lift(_i.named, |it| _visitor.fold_field(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_fields_unnamed<V: Fold + ?Sized>(_visitor: &mut V, _i: FieldsUnnamed) -> FieldsUnnamed {
    FieldsUnnamed {
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        unnamed: FoldHelper::lift(_i.unnamed, |it| _visitor.fold_field(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_file<V: Fold + ?Sized>(_visitor: &mut V, _i: File) -> File {
    File {
        shebang: _i.shebang,
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        items: FoldHelper::lift(_i.items, |it| _visitor.fold_item(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_fn_arg<V: Fold + ?Sized>(_visitor: &mut V, _i: FnArg) -> FnArg {
    match _i {
        FnArg::SelfRef(_binding_0) => FnArg::SelfRef(_visitor.fold_arg_self_ref(_binding_0)),
        FnArg::SelfValue(_binding_0) => FnArg::SelfValue(_visitor.fold_arg_self(_binding_0)),
        FnArg::Captured(_binding_0) => FnArg::Captured(_visitor.fold_arg_captured(_binding_0)),
        FnArg::Inferred(_binding_0) => FnArg::Inferred(_visitor.fold_pat(_binding_0)),
        FnArg::Ignored(_binding_0) => FnArg::Ignored(_visitor.fold_type(_binding_0)),
    }
}
#[cfg(feature = "full")]
pub fn fold_fn_decl<V: Fold + ?Sized>(_visitor: &mut V, _i: FnDecl) -> FnDecl {
    FnDecl {
        fn_token: Token![fn](tokens_helper(_visitor, &_i.fn_token.span)),
        generics: _visitor.fold_generics(_i.generics),
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        inputs: FoldHelper::lift(_i.inputs, |it| _visitor.fold_fn_arg(it)),
        variadic: (_i.variadic).map(|it| Token ! [ ... ](tokens_helper(_visitor, &it.spans))),
        output: _visitor.fold_return_type(_i.output),
    }
}
#[cfg(feature = "full")]
pub fn fold_foreign_item<V: Fold + ?Sized>(_visitor: &mut V, _i: ForeignItem) -> ForeignItem {
    match _i {
        ForeignItem::Fn(_binding_0) => ForeignItem::Fn(_visitor.fold_foreign_item_fn(_binding_0)),
        ForeignItem::Static(_binding_0) => {
            ForeignItem::Static(_visitor.fold_foreign_item_static(_binding_0))
        }
        ForeignItem::Type(_binding_0) => {
            ForeignItem::Type(_visitor.fold_foreign_item_type(_binding_0))
        }
        ForeignItem::Macro(_binding_0) => {
            ForeignItem::Macro(_visitor.fold_foreign_item_macro(_binding_0))
        }
        ForeignItem::Verbatim(_binding_0) => {
            ForeignItem::Verbatim(_visitor.fold_foreign_item_verbatim(_binding_0))
        }
    }
}
#[cfg(feature = "full")]
pub fn fold_foreign_item_fn<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ForeignItemFn,
) -> ForeignItemFn {
    ForeignItemFn {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        ident: _visitor.fold_ident(_i.ident),
        decl: Box::new(_visitor.fold_fn_decl(*_i.decl)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_foreign_item_macro<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ForeignItemMacro,
) -> ForeignItemMacro {
    ForeignItemMacro {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        mac: _visitor.fold_macro(_i.mac),
        semi_token: (_i.semi_token).map(|it| Token ! [ ; ](tokens_helper(_visitor, &it.spans))),
    }
}
#[cfg(feature = "full")]
pub fn fold_foreign_item_static<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ForeignItemStatic,
) -> ForeignItemStatic {
    ForeignItemStatic {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        static_token: Token![static](tokens_helper(_visitor, &_i.static_token.span)),
        mutability: (_i.mutability).map(|it| Token![mut](tokens_helper(_visitor, &it.span))),
        ident: _visitor.fold_ident(_i.ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &_i.colon_token.spans)),
        ty: Box::new(_visitor.fold_type(*_i.ty)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_foreign_item_type<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ForeignItemType,
) -> ForeignItemType {
    ForeignItemType {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        type_token: Token![type](tokens_helper(_visitor, &_i.type_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_foreign_item_verbatim<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ForeignItemVerbatim,
) -> ForeignItemVerbatim {
    ForeignItemVerbatim { tts: _i.tts }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_generic_argument<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: GenericArgument,
) -> GenericArgument {
    match _i {
        GenericArgument::Lifetime(_binding_0) => {
            GenericArgument::Lifetime(_visitor.fold_lifetime(_binding_0))
        }
        GenericArgument::Type(_binding_0) => GenericArgument::Type(_visitor.fold_type(_binding_0)),
        GenericArgument::Binding(_binding_0) => {
            GenericArgument::Binding(_visitor.fold_binding(_binding_0))
        }
        GenericArgument::Constraint(_binding_0) => {
            GenericArgument::Constraint(_visitor.fold_constraint(_binding_0))
        }
        GenericArgument::Const(_binding_0) => {
            GenericArgument::Const(_visitor.fold_expr(_binding_0))
        }
    }
}
#[cfg(feature = "full")]
pub fn fold_generic_method_argument<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: GenericMethodArgument,
) -> GenericMethodArgument {
    match _i {
        GenericMethodArgument::Type(_binding_0) => {
            GenericMethodArgument::Type(_visitor.fold_type(_binding_0))
        }
        GenericMethodArgument::Const(_binding_0) => {
            GenericMethodArgument::Const(_visitor.fold_expr(_binding_0))
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_generic_param<V: Fold + ?Sized>(_visitor: &mut V, _i: GenericParam) -> GenericParam {
    match _i {
        GenericParam::Type(_binding_0) => GenericParam::Type(_visitor.fold_type_param(_binding_0)),
        GenericParam::Lifetime(_binding_0) => {
            GenericParam::Lifetime(_visitor.fold_lifetime_def(_binding_0))
        }
        GenericParam::Const(_binding_0) => {
            GenericParam::Const(_visitor.fold_const_param(_binding_0))
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_generics<V: Fold + ?Sized>(_visitor: &mut V, _i: Generics) -> Generics {
    Generics {
        lt_token: (_i.lt_token).map(|it| Token ! [ < ](tokens_helper(_visitor, &it.spans))),
        params: FoldHelper::lift(_i.params, |it| _visitor.fold_generic_param(it)),
        gt_token: (_i.gt_token).map(|it| Token ! [ > ](tokens_helper(_visitor, &it.spans))),
        where_clause: (_i.where_clause).map(|it| _visitor.fold_where_clause(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_impl_item<V: Fold + ?Sized>(_visitor: &mut V, _i: ImplItem) -> ImplItem {
    match _i {
        ImplItem::Const(_binding_0) => ImplItem::Const(_visitor.fold_impl_item_const(_binding_0)),
        ImplItem::Method(_binding_0) => {
            ImplItem::Method(_visitor.fold_impl_item_method(_binding_0))
        }
        ImplItem::Type(_binding_0) => ImplItem::Type(_visitor.fold_impl_item_type(_binding_0)),
        ImplItem::Existential(_binding_0) => {
            ImplItem::Existential(_visitor.fold_impl_item_existential(_binding_0))
        }
        ImplItem::Macro(_binding_0) => ImplItem::Macro(_visitor.fold_impl_item_macro(_binding_0)),
        ImplItem::Verbatim(_binding_0) => {
            ImplItem::Verbatim(_visitor.fold_impl_item_verbatim(_binding_0))
        }
    }
}
#[cfg(feature = "full")]
pub fn fold_impl_item_const<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ImplItemConst,
) -> ImplItemConst {
    ImplItemConst {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        defaultness: (_i.defaultness).map(|it| Token![default](tokens_helper(_visitor, &it.span))),
        const_token: Token![const](tokens_helper(_visitor, &_i.const_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &_i.colon_token.spans)),
        ty: _visitor.fold_type(_i.ty),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &_i.eq_token.spans)),
        expr: _visitor.fold_expr(_i.expr),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_impl_item_existential<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ImplItemExistential,
) -> ImplItemExistential {
    ImplItemExistential {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        existential_token: Token![existential](tokens_helper(_visitor, &_i.existential_token.span)),
        type_token: Token![type](tokens_helper(_visitor, &_i.type_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        generics: _visitor.fold_generics(_i.generics),
        colon_token: (_i.colon_token).map(|it| Token ! [ : ](tokens_helper(_visitor, &it.spans))),
        bounds: FoldHelper::lift(_i.bounds, |it| _visitor.fold_type_param_bound(it)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_impl_item_macro<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ImplItemMacro,
) -> ImplItemMacro {
    ImplItemMacro {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        mac: _visitor.fold_macro(_i.mac),
        semi_token: (_i.semi_token).map(|it| Token ! [ ; ](tokens_helper(_visitor, &it.spans))),
    }
}
#[cfg(feature = "full")]
pub fn fold_impl_item_method<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ImplItemMethod,
) -> ImplItemMethod {
    ImplItemMethod {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        defaultness: (_i.defaultness).map(|it| Token![default](tokens_helper(_visitor, &it.span))),
        sig: _visitor.fold_method_sig(_i.sig),
        block: _visitor.fold_block(_i.block),
    }
}
#[cfg(feature = "full")]
pub fn fold_impl_item_type<V: Fold + ?Sized>(_visitor: &mut V, _i: ImplItemType) -> ImplItemType {
    ImplItemType {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        defaultness: (_i.defaultness).map(|it| Token![default](tokens_helper(_visitor, &it.span))),
        type_token: Token![type](tokens_helper(_visitor, &_i.type_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        generics: _visitor.fold_generics(_i.generics),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &_i.eq_token.spans)),
        ty: _visitor.fold_type(_i.ty),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_impl_item_verbatim<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ImplItemVerbatim,
) -> ImplItemVerbatim {
    ImplItemVerbatim { tts: _i.tts }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_index<V: Fold + ?Sized>(_visitor: &mut V, _i: Index) -> Index {
    Index {
        index: _i.index,
        span: _visitor.fold_span(_i.span),
    }
}
#[cfg(feature = "full")]
pub fn fold_item<V: Fold + ?Sized>(_visitor: &mut V, _i: Item) -> Item {
    match _i {
        Item::ExternCrate(_binding_0) => {
            Item::ExternCrate(_visitor.fold_item_extern_crate(_binding_0))
        }
        Item::Use(_binding_0) => Item::Use(_visitor.fold_item_use(_binding_0)),
        Item::Static(_binding_0) => Item::Static(_visitor.fold_item_static(_binding_0)),
        Item::Const(_binding_0) => Item::Const(_visitor.fold_item_const(_binding_0)),
        Item::Fn(_binding_0) => Item::Fn(_visitor.fold_item_fn(_binding_0)),
        Item::Mod(_binding_0) => Item::Mod(_visitor.fold_item_mod(_binding_0)),
        Item::ForeignMod(_binding_0) => {
            Item::ForeignMod(_visitor.fold_item_foreign_mod(_binding_0))
        }
        Item::Type(_binding_0) => Item::Type(_visitor.fold_item_type(_binding_0)),
        Item::Existential(_binding_0) => {
            Item::Existential(_visitor.fold_item_existential(_binding_0))
        }
        Item::Struct(_binding_0) => Item::Struct(_visitor.fold_item_struct(_binding_0)),
        Item::Enum(_binding_0) => Item::Enum(_visitor.fold_item_enum(_binding_0)),
        Item::Union(_binding_0) => Item::Union(_visitor.fold_item_union(_binding_0)),
        Item::Trait(_binding_0) => Item::Trait(_visitor.fold_item_trait(_binding_0)),
        Item::TraitAlias(_binding_0) => {
            Item::TraitAlias(_visitor.fold_item_trait_alias(_binding_0))
        }
        Item::Impl(_binding_0) => Item::Impl(_visitor.fold_item_impl(_binding_0)),
        Item::Macro(_binding_0) => Item::Macro(_visitor.fold_item_macro(_binding_0)),
        Item::Macro2(_binding_0) => Item::Macro2(_visitor.fold_item_macro2(_binding_0)),
        Item::Verbatim(_binding_0) => Item::Verbatim(_visitor.fold_item_verbatim(_binding_0)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_const<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemConst) -> ItemConst {
    ItemConst {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        const_token: Token![const](tokens_helper(_visitor, &_i.const_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &_i.colon_token.spans)),
        ty: Box::new(_visitor.fold_type(*_i.ty)),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &_i.eq_token.spans)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_enum<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemEnum) -> ItemEnum {
    ItemEnum {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        enum_token: Token![enum](tokens_helper(_visitor, &_i.enum_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        generics: _visitor.fold_generics(_i.generics),
        brace_token: Brace(tokens_helper(_visitor, &_i.brace_token.span)),
        variants: FoldHelper::lift(_i.variants, |it| _visitor.fold_variant(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_existential<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ItemExistential,
) -> ItemExistential {
    ItemExistential {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        existential_token: Token![existential](tokens_helper(_visitor, &_i.existential_token.span)),
        type_token: Token![type](tokens_helper(_visitor, &_i.type_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        generics: _visitor.fold_generics(_i.generics),
        colon_token: (_i.colon_token).map(|it| Token ! [ : ](tokens_helper(_visitor, &it.spans))),
        bounds: FoldHelper::lift(_i.bounds, |it| _visitor.fold_type_param_bound(it)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_extern_crate<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ItemExternCrate,
) -> ItemExternCrate {
    ItemExternCrate {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        extern_token: Token![extern](tokens_helper(_visitor, &_i.extern_token.span)),
        crate_token: Token![crate](tokens_helper(_visitor, &_i.crate_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        rename: (_i.rename).map(|it| {
            (
                Token![as](tokens_helper(_visitor, &(it).0.span)),
                _visitor.fold_ident((it).1),
            )
        }),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_fn<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemFn) -> ItemFn {
    ItemFn {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        constness: (_i.constness).map(|it| Token![const](tokens_helper(_visitor, &it.span))),
        unsafety: (_i.unsafety).map(|it| Token![unsafe](tokens_helper(_visitor, &it.span))),
        asyncness: (_i.asyncness).map(|it| Token![async](tokens_helper(_visitor, &it.span))),
        abi: (_i.abi).map(|it| _visitor.fold_abi(it)),
        ident: _visitor.fold_ident(_i.ident),
        decl: Box::new(_visitor.fold_fn_decl(*_i.decl)),
        block: Box::new(_visitor.fold_block(*_i.block)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_foreign_mod<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ItemForeignMod,
) -> ItemForeignMod {
    ItemForeignMod {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        abi: _visitor.fold_abi(_i.abi),
        brace_token: Brace(tokens_helper(_visitor, &_i.brace_token.span)),
        items: FoldHelper::lift(_i.items, |it| _visitor.fold_foreign_item(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_impl<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemImpl) -> ItemImpl {
    ItemImpl {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        defaultness: (_i.defaultness).map(|it| Token![default](tokens_helper(_visitor, &it.span))),
        unsafety: (_i.unsafety).map(|it| Token![unsafe](tokens_helper(_visitor, &it.span))),
        impl_token: Token![impl](tokens_helper(_visitor, &_i.impl_token.span)),
        generics: _visitor.fold_generics(_i.generics),
        trait_: (_i.trait_).map(|it| {
            (
                ((it).0).map(|it| Token![!](tokens_helper(_visitor, &it.spans))),
                _visitor.fold_path((it).1),
                Token![for](tokens_helper(_visitor, &(it).2.span)),
            )
        }),
        self_ty: Box::new(_visitor.fold_type(*_i.self_ty)),
        brace_token: Brace(tokens_helper(_visitor, &_i.brace_token.span)),
        items: FoldHelper::lift(_i.items, |it| _visitor.fold_impl_item(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_macro<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemMacro) -> ItemMacro {
    ItemMacro {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        ident: (_i.ident).map(|it| _visitor.fold_ident(it)),
        mac: _visitor.fold_macro(_i.mac),
        semi_token: (_i.semi_token).map(|it| Token ! [ ; ](tokens_helper(_visitor, &it.spans))),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_macro2<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemMacro2) -> ItemMacro2 {
    ItemMacro2 {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        macro_token: Token![macro](tokens_helper(_visitor, &_i.macro_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        args: _i.args,
        brace_token: Brace(tokens_helper(_visitor, &_i.brace_token.span)),
        body: _i.body,
    }
}
#[cfg(feature = "full")]
pub fn fold_item_mod<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemMod) -> ItemMod {
    ItemMod {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        mod_token: Token![mod](tokens_helper(_visitor, &_i.mod_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        content: (_i.content).map(|it| {
            (
                Brace(tokens_helper(_visitor, &(it).0.span)),
                FoldHelper::lift((it).1, |it| _visitor.fold_item(it)),
            )
        }),
        semi: (_i.semi).map(|it| Token ! [ ; ](tokens_helper(_visitor, &it.spans))),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_static<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemStatic) -> ItemStatic {
    ItemStatic {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        static_token: Token![static](tokens_helper(_visitor, &_i.static_token.span)),
        mutability: (_i.mutability).map(|it| Token![mut](tokens_helper(_visitor, &it.span))),
        ident: _visitor.fold_ident(_i.ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &_i.colon_token.spans)),
        ty: Box::new(_visitor.fold_type(*_i.ty)),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &_i.eq_token.spans)),
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_struct<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemStruct) -> ItemStruct {
    ItemStruct {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        struct_token: Token![struct](tokens_helper(_visitor, &_i.struct_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        generics: _visitor.fold_generics(_i.generics),
        fields: _visitor.fold_fields(_i.fields),
        semi_token: (_i.semi_token).map(|it| Token ! [ ; ](tokens_helper(_visitor, &it.spans))),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_trait<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemTrait) -> ItemTrait {
    ItemTrait {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        unsafety: (_i.unsafety).map(|it| Token![unsafe](tokens_helper(_visitor, &it.span))),
        auto_token: (_i.auto_token).map(|it| Token![auto](tokens_helper(_visitor, &it.span))),
        trait_token: Token![trait](tokens_helper(_visitor, &_i.trait_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        generics: _visitor.fold_generics(_i.generics),
        colon_token: (_i.colon_token).map(|it| Token ! [ : ](tokens_helper(_visitor, &it.spans))),
        supertraits: FoldHelper::lift(_i.supertraits, |it| _visitor.fold_type_param_bound(it)),
        brace_token: Brace(tokens_helper(_visitor, &_i.brace_token.span)),
        items: FoldHelper::lift(_i.items, |it| _visitor.fold_trait_item(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_trait_alias<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ItemTraitAlias,
) -> ItemTraitAlias {
    ItemTraitAlias {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        trait_token: Token![trait](tokens_helper(_visitor, &_i.trait_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        generics: _visitor.fold_generics(_i.generics),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &_i.eq_token.spans)),
        bounds: FoldHelper::lift(_i.bounds, |it| _visitor.fold_type_param_bound(it)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_type<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemType) -> ItemType {
    ItemType {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        type_token: Token![type](tokens_helper(_visitor, &_i.type_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        generics: _visitor.fold_generics(_i.generics),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &_i.eq_token.spans)),
        ty: Box::new(_visitor.fold_type(*_i.ty)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_union<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemUnion) -> ItemUnion {
    ItemUnion {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        union_token: Token![union](tokens_helper(_visitor, &_i.union_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        generics: _visitor.fold_generics(_i.generics),
        fields: _visitor.fold_fields_named(_i.fields),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_use<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemUse) -> ItemUse {
    ItemUse {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        vis: _visitor.fold_visibility(_i.vis),
        use_token: Token![use](tokens_helper(_visitor, &_i.use_token.span)),
        leading_colon: (_i.leading_colon)
            .map(|it| Token ! [ :: ](tokens_helper(_visitor, &it.spans))),
        tree: _visitor.fold_use_tree(_i.tree),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_item_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemVerbatim) -> ItemVerbatim {
    ItemVerbatim { tts: _i.tts }
}
#[cfg(feature = "full")]
pub fn fold_label<V: Fold + ?Sized>(_visitor: &mut V, _i: Label) -> Label {
    Label {
        name: _visitor.fold_lifetime(_i.name),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &_i.colon_token.spans)),
    }
}
pub fn fold_lifetime<V: Fold + ?Sized>(_visitor: &mut V, _i: Lifetime) -> Lifetime {
    Lifetime {
        apostrophe: _visitor.fold_span(_i.apostrophe),
        ident: _visitor.fold_ident(_i.ident),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_lifetime_def<V: Fold + ?Sized>(_visitor: &mut V, _i: LifetimeDef) -> LifetimeDef {
    LifetimeDef {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        lifetime: _visitor.fold_lifetime(_i.lifetime),
        colon_token: (_i.colon_token).map(|it| Token ! [ : ](tokens_helper(_visitor, &it.spans))),
        bounds: FoldHelper::lift(_i.bounds, |it| _visitor.fold_lifetime(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_lit<V: Fold + ?Sized>(_visitor: &mut V, _i: Lit) -> Lit {
    match _i {
        Lit::Str(_binding_0) => Lit::Str(_visitor.fold_lit_str(_binding_0)),
        Lit::ByteStr(_binding_0) => Lit::ByteStr(_visitor.fold_lit_byte_str(_binding_0)),
        Lit::Byte(_binding_0) => Lit::Byte(_visitor.fold_lit_byte(_binding_0)),
        Lit::Char(_binding_0) => Lit::Char(_visitor.fold_lit_char(_binding_0)),
        Lit::Int(_binding_0) => Lit::Int(_visitor.fold_lit_int(_binding_0)),
        Lit::Float(_binding_0) => Lit::Float(_visitor.fold_lit_float(_binding_0)),
        Lit::Bool(_binding_0) => Lit::Bool(_visitor.fold_lit_bool(_binding_0)),
        Lit::Verbatim(_binding_0) => Lit::Verbatim(_visitor.fold_lit_verbatim(_binding_0)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_lit_bool<V: Fold + ?Sized>(_visitor: &mut V, _i: LitBool) -> LitBool {
    LitBool {
        value: _i.value,
        span: _visitor.fold_span(_i.span),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_lit_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: LitVerbatim) -> LitVerbatim {
    LitVerbatim { token: _i.token }
}
#[cfg(feature = "full")]
pub fn fold_local<V: Fold + ?Sized>(_visitor: &mut V, _i: Local) -> Local {
    Local {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        let_token: Token![let](tokens_helper(_visitor, &_i.let_token.span)),
        pats: FoldHelper::lift(_i.pats, |it| _visitor.fold_pat(it)),
        ty: (_i.ty).map(|it| {
            (
                Token ! [ : ](tokens_helper(_visitor, &(it).0.spans)),
                Box::new(_visitor.fold_type(*(it).1)),
            )
        }),
        init: (_i.init).map(|it| {
            (
                Token ! [ = ](tokens_helper(_visitor, &(it).0.spans)),
                Box::new(_visitor.fold_expr(*(it).1)),
            )
        }),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_macro<V: Fold + ?Sized>(_visitor: &mut V, _i: Macro) -> Macro {
    Macro {
        path: _visitor.fold_path(_i.path),
        bang_token: Token![!](tokens_helper(_visitor, &_i.bang_token.spans)),
        delimiter: _visitor.fold_macro_delimiter(_i.delimiter),
        tts: _i.tts,
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_macro_delimiter<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: MacroDelimiter,
) -> MacroDelimiter {
    match _i {
        MacroDelimiter::Paren(_binding_0) => {
            MacroDelimiter::Paren(Paren(tokens_helper(_visitor, &_binding_0.span)))
        }
        MacroDelimiter::Brace(_binding_0) => {
            MacroDelimiter::Brace(Brace(tokens_helper(_visitor, &_binding_0.span)))
        }
        MacroDelimiter::Bracket(_binding_0) => {
            MacroDelimiter::Bracket(Bracket(tokens_helper(_visitor, &_binding_0.span)))
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_member<V: Fold + ?Sized>(_visitor: &mut V, _i: Member) -> Member {
    match _i {
        Member::Named(_binding_0) => Member::Named(_visitor.fold_ident(_binding_0)),
        Member::Unnamed(_binding_0) => Member::Unnamed(_visitor.fold_index(_binding_0)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_meta<V: Fold + ?Sized>(_visitor: &mut V, _i: Meta) -> Meta {
    match _i {
        Meta::Word(_binding_0) => Meta::Word(_visitor.fold_ident(_binding_0)),
        Meta::List(_binding_0) => Meta::List(_visitor.fold_meta_list(_binding_0)),
        Meta::NameValue(_binding_0) => Meta::NameValue(_visitor.fold_meta_name_value(_binding_0)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_meta_list<V: Fold + ?Sized>(_visitor: &mut V, _i: MetaList) -> MetaList {
    MetaList {
        ident: _visitor.fold_ident(_i.ident),
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        nested: FoldHelper::lift(_i.nested, |it| _visitor.fold_nested_meta(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_meta_name_value<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: MetaNameValue,
) -> MetaNameValue {
    MetaNameValue {
        ident: _visitor.fold_ident(_i.ident),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &_i.eq_token.spans)),
        lit: _visitor.fold_lit(_i.lit),
    }
}
#[cfg(feature = "full")]
pub fn fold_method_sig<V: Fold + ?Sized>(_visitor: &mut V, _i: MethodSig) -> MethodSig {
    MethodSig {
        constness: (_i.constness).map(|it| Token![const](tokens_helper(_visitor, &it.span))),
        unsafety: (_i.unsafety).map(|it| Token![unsafe](tokens_helper(_visitor, &it.span))),
        asyncness: (_i.asyncness).map(|it| Token![async](tokens_helper(_visitor, &it.span))),
        abi: (_i.abi).map(|it| _visitor.fold_abi(it)),
        ident: _visitor.fold_ident(_i.ident),
        decl: _visitor.fold_fn_decl(_i.decl),
    }
}
#[cfg(feature = "full")]
pub fn fold_method_turbofish<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: MethodTurbofish,
) -> MethodTurbofish {
    MethodTurbofish {
        colon2_token: Token ! [ :: ](tokens_helper(_visitor, &_i.colon2_token.spans)),
        lt_token: Token ! [ < ](tokens_helper(_visitor, &_i.lt_token.spans)),
        args: FoldHelper::lift(_i.args, |it| _visitor.fold_generic_method_argument(it)),
        gt_token: Token ! [ > ](tokens_helper(_visitor, &_i.gt_token.spans)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_nested_meta<V: Fold + ?Sized>(_visitor: &mut V, _i: NestedMeta) -> NestedMeta {
    match _i {
        NestedMeta::Meta(_binding_0) => NestedMeta::Meta(_visitor.fold_meta(_binding_0)),
        NestedMeta::Literal(_binding_0) => NestedMeta::Literal(_visitor.fold_lit(_binding_0)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_parenthesized_generic_arguments<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: ParenthesizedGenericArguments,
) -> ParenthesizedGenericArguments {
    ParenthesizedGenericArguments {
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        inputs: FoldHelper::lift(_i.inputs, |it| _visitor.fold_type(it)),
        output: _visitor.fold_return_type(_i.output),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat<V: Fold + ?Sized>(_visitor: &mut V, _i: Pat) -> Pat {
    match _i {
        Pat::Wild(_binding_0) => Pat::Wild(_visitor.fold_pat_wild(_binding_0)),
        Pat::Ident(_binding_0) => Pat::Ident(_visitor.fold_pat_ident(_binding_0)),
        Pat::Struct(_binding_0) => Pat::Struct(_visitor.fold_pat_struct(_binding_0)),
        Pat::TupleStruct(_binding_0) => {
            Pat::TupleStruct(_visitor.fold_pat_tuple_struct(_binding_0))
        }
        Pat::Path(_binding_0) => Pat::Path(_visitor.fold_pat_path(_binding_0)),
        Pat::Tuple(_binding_0) => Pat::Tuple(_visitor.fold_pat_tuple(_binding_0)),
        Pat::Box(_binding_0) => Pat::Box(_visitor.fold_pat_box(_binding_0)),
        Pat::Ref(_binding_0) => Pat::Ref(_visitor.fold_pat_ref(_binding_0)),
        Pat::Lit(_binding_0) => Pat::Lit(_visitor.fold_pat_lit(_binding_0)),
        Pat::Range(_binding_0) => Pat::Range(_visitor.fold_pat_range(_binding_0)),
        Pat::Slice(_binding_0) => Pat::Slice(_visitor.fold_pat_slice(_binding_0)),
        Pat::Macro(_binding_0) => Pat::Macro(_visitor.fold_pat_macro(_binding_0)),
        Pat::Verbatim(_binding_0) => Pat::Verbatim(_visitor.fold_pat_verbatim(_binding_0)),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat_box<V: Fold + ?Sized>(_visitor: &mut V, _i: PatBox) -> PatBox {
    PatBox {
        box_token: Token![box](tokens_helper(_visitor, &_i.box_token.span)),
        pat: Box::new(_visitor.fold_pat(*_i.pat)),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat_ident<V: Fold + ?Sized>(_visitor: &mut V, _i: PatIdent) -> PatIdent {
    PatIdent {
        by_ref: (_i.by_ref).map(|it| Token![ref](tokens_helper(_visitor, &it.span))),
        mutability: (_i.mutability).map(|it| Token![mut](tokens_helper(_visitor, &it.span))),
        ident: _visitor.fold_ident(_i.ident),
        subpat: (_i.subpat).map(|it| {
            (
                Token ! [ @ ](tokens_helper(_visitor, &(it).0.spans)),
                Box::new(_visitor.fold_pat(*(it).1)),
            )
        }),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat_lit<V: Fold + ?Sized>(_visitor: &mut V, _i: PatLit) -> PatLit {
    PatLit {
        expr: Box::new(_visitor.fold_expr(*_i.expr)),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat_macro<V: Fold + ?Sized>(_visitor: &mut V, _i: PatMacro) -> PatMacro {
    PatMacro {
        mac: _visitor.fold_macro(_i.mac),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat_path<V: Fold + ?Sized>(_visitor: &mut V, _i: PatPath) -> PatPath {
    PatPath {
        qself: (_i.qself).map(|it| _visitor.fold_qself(it)),
        path: _visitor.fold_path(_i.path),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat_range<V: Fold + ?Sized>(_visitor: &mut V, _i: PatRange) -> PatRange {
    PatRange {
        lo: Box::new(_visitor.fold_expr(*_i.lo)),
        limits: _visitor.fold_range_limits(_i.limits),
        hi: Box::new(_visitor.fold_expr(*_i.hi)),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat_ref<V: Fold + ?Sized>(_visitor: &mut V, _i: PatRef) -> PatRef {
    PatRef {
        and_token: Token ! [ & ](tokens_helper(_visitor, &_i.and_token.spans)),
        mutability: (_i.mutability).map(|it| Token![mut](tokens_helper(_visitor, &it.span))),
        pat: Box::new(_visitor.fold_pat(*_i.pat)),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat_slice<V: Fold + ?Sized>(_visitor: &mut V, _i: PatSlice) -> PatSlice {
    PatSlice {
        bracket_token: Bracket(tokens_helper(_visitor, &_i.bracket_token.span)),
        front: FoldHelper::lift(_i.front, |it| _visitor.fold_pat(it)),
        middle: (_i.middle).map(|it| Box::new(_visitor.fold_pat(*it))),
        dot2_token: (_i.dot2_token).map(|it| Token![..](tokens_helper(_visitor, &it.spans))),
        comma_token: (_i.comma_token).map(|it| Token ! [ , ](tokens_helper(_visitor, &it.spans))),
        back: FoldHelper::lift(_i.back, |it| _visitor.fold_pat(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat_struct<V: Fold + ?Sized>(_visitor: &mut V, _i: PatStruct) -> PatStruct {
    PatStruct {
        path: _visitor.fold_path(_i.path),
        brace_token: Brace(tokens_helper(_visitor, &_i.brace_token.span)),
        fields: FoldHelper::lift(_i.fields, |it| _visitor.fold_field_pat(it)),
        dot2_token: (_i.dot2_token).map(|it| Token![..](tokens_helper(_visitor, &it.spans))),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat_tuple<V: Fold + ?Sized>(_visitor: &mut V, _i: PatTuple) -> PatTuple {
    PatTuple {
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        front: FoldHelper::lift(_i.front, |it| _visitor.fold_pat(it)),
        dot2_token: (_i.dot2_token).map(|it| Token![..](tokens_helper(_visitor, &it.spans))),
        comma_token: (_i.comma_token).map(|it| Token ! [ , ](tokens_helper(_visitor, &it.spans))),
        back: FoldHelper::lift(_i.back, |it| _visitor.fold_pat(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat_tuple_struct<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: PatTupleStruct,
) -> PatTupleStruct {
    PatTupleStruct {
        path: _visitor.fold_path(_i.path),
        pat: _visitor.fold_pat_tuple(_i.pat),
    }
}
#[cfg(feature = "full")]
pub fn fold_pat_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: PatVerbatim) -> PatVerbatim {
    PatVerbatim { tts: _i.tts }
}
#[cfg(feature = "full")]
pub fn fold_pat_wild<V: Fold + ?Sized>(_visitor: &mut V, _i: PatWild) -> PatWild {
    PatWild {
        underscore_token: Token![_](tokens_helper(_visitor, &_i.underscore_token.spans)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_path<V: Fold + ?Sized>(_visitor: &mut V, _i: Path) -> Path {
    Path {
        leading_colon: (_i.leading_colon)
            .map(|it| Token ! [ :: ](tokens_helper(_visitor, &it.spans))),
        segments: FoldHelper::lift(_i.segments, |it| _visitor.fold_path_segment(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_path_arguments<V: Fold + ?Sized>(_visitor: &mut V, _i: PathArguments) -> PathArguments {
    match _i {
        PathArguments::None => PathArguments::None,
        PathArguments::AngleBracketed(_binding_0) => PathArguments::AngleBracketed(
            _visitor.fold_angle_bracketed_generic_arguments(_binding_0),
        ),
        PathArguments::Parenthesized(_binding_0) => {
            PathArguments::Parenthesized(_visitor.fold_parenthesized_generic_arguments(_binding_0))
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_path_segment<V: Fold + ?Sized>(_visitor: &mut V, _i: PathSegment) -> PathSegment {
    PathSegment {
        ident: _visitor.fold_ident(_i.ident),
        arguments: _visitor.fold_path_arguments(_i.arguments),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_predicate_eq<V: Fold + ?Sized>(_visitor: &mut V, _i: PredicateEq) -> PredicateEq {
    PredicateEq {
        lhs_ty: _visitor.fold_type(_i.lhs_ty),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &_i.eq_token.spans)),
        rhs_ty: _visitor.fold_type(_i.rhs_ty),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_predicate_lifetime<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: PredicateLifetime,
) -> PredicateLifetime {
    PredicateLifetime {
        lifetime: _visitor.fold_lifetime(_i.lifetime),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &_i.colon_token.spans)),
        bounds: FoldHelper::lift(_i.bounds, |it| _visitor.fold_lifetime(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_predicate_type<V: Fold + ?Sized>(_visitor: &mut V, _i: PredicateType) -> PredicateType {
    PredicateType {
        lifetimes: (_i.lifetimes).map(|it| _visitor.fold_bound_lifetimes(it)),
        bounded_ty: _visitor.fold_type(_i.bounded_ty),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &_i.colon_token.spans)),
        bounds: FoldHelper::lift(_i.bounds, |it| _visitor.fold_type_param_bound(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_qself<V: Fold + ?Sized>(_visitor: &mut V, _i: QSelf) -> QSelf {
    QSelf {
        lt_token: Token ! [ < ](tokens_helper(_visitor, &_i.lt_token.spans)),
        ty: Box::new(_visitor.fold_type(*_i.ty)),
        position: _i.position,
        as_token: (_i.as_token).map(|it| Token![as](tokens_helper(_visitor, &it.span))),
        gt_token: Token ! [ > ](tokens_helper(_visitor, &_i.gt_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_range_limits<V: Fold + ?Sized>(_visitor: &mut V, _i: RangeLimits) -> RangeLimits {
    match _i {
        RangeLimits::HalfOpen(_binding_0) => {
            RangeLimits::HalfOpen(Token![..](tokens_helper(_visitor, &_binding_0.spans)))
        }
        RangeLimits::Closed(_binding_0) => {
            RangeLimits::Closed(Token ! [ ..= ](tokens_helper(_visitor, &_binding_0.spans)))
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_return_type<V: Fold + ?Sized>(_visitor: &mut V, _i: ReturnType) -> ReturnType {
    match _i {
        ReturnType::Default => ReturnType::Default,
        ReturnType::Type(_binding_0, _binding_1) => ReturnType::Type(
            Token ! [ -> ](tokens_helper(_visitor, &_binding_0.spans)),
            Box::new(_visitor.fold_type(*_binding_1)),
        ),
    }
}
#[cfg(feature = "full")]
pub fn fold_stmt<V: Fold + ?Sized>(_visitor: &mut V, _i: Stmt) -> Stmt {
    match _i {
        Stmt::Local(_binding_0) => Stmt::Local(_visitor.fold_local(_binding_0)),
        Stmt::Item(_binding_0) => Stmt::Item(_visitor.fold_item(_binding_0)),
        Stmt::Expr(_binding_0) => Stmt::Expr(_visitor.fold_expr(_binding_0)),
        Stmt::Semi(_binding_0, _binding_1) => Stmt::Semi(
            _visitor.fold_expr(_binding_0),
            Token ! [ ; ](tokens_helper(_visitor, &_binding_1.spans)),
        ),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_trait_bound<V: Fold + ?Sized>(_visitor: &mut V, _i: TraitBound) -> TraitBound {
    TraitBound {
        paren_token: (_i.paren_token).map(|it| Paren(tokens_helper(_visitor, &it.span))),
        modifier: _visitor.fold_trait_bound_modifier(_i.modifier),
        lifetimes: (_i.lifetimes).map(|it| _visitor.fold_bound_lifetimes(it)),
        path: _visitor.fold_path(_i.path),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_trait_bound_modifier<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: TraitBoundModifier,
) -> TraitBoundModifier {
    match _i {
        TraitBoundModifier::None => TraitBoundModifier::None,
        TraitBoundModifier::Maybe(_binding_0) => {
            TraitBoundModifier::Maybe(Token ! [ ? ](tokens_helper(_visitor, &_binding_0.spans)))
        }
    }
}
#[cfg(feature = "full")]
pub fn fold_trait_item<V: Fold + ?Sized>(_visitor: &mut V, _i: TraitItem) -> TraitItem {
    match _i {
        TraitItem::Const(_binding_0) => {
            TraitItem::Const(_visitor.fold_trait_item_const(_binding_0))
        }
        TraitItem::Method(_binding_0) => {
            TraitItem::Method(_visitor.fold_trait_item_method(_binding_0))
        }
        TraitItem::Type(_binding_0) => TraitItem::Type(_visitor.fold_trait_item_type(_binding_0)),
        TraitItem::Macro(_binding_0) => {
            TraitItem::Macro(_visitor.fold_trait_item_macro(_binding_0))
        }
        TraitItem::Verbatim(_binding_0) => {
            TraitItem::Verbatim(_visitor.fold_trait_item_verbatim(_binding_0))
        }
    }
}
#[cfg(feature = "full")]
pub fn fold_trait_item_const<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: TraitItemConst,
) -> TraitItemConst {
    TraitItemConst {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        const_token: Token![const](tokens_helper(_visitor, &_i.const_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &_i.colon_token.spans)),
        ty: _visitor.fold_type(_i.ty),
        default: (_i.default).map(|it| {
            (
                Token ! [ = ](tokens_helper(_visitor, &(it).0.spans)),
                _visitor.fold_expr((it).1),
            )
        }),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_trait_item_macro<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: TraitItemMacro,
) -> TraitItemMacro {
    TraitItemMacro {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        mac: _visitor.fold_macro(_i.mac),
        semi_token: (_i.semi_token).map(|it| Token ! [ ; ](tokens_helper(_visitor, &it.spans))),
    }
}
#[cfg(feature = "full")]
pub fn fold_trait_item_method<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: TraitItemMethod,
) -> TraitItemMethod {
    TraitItemMethod {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        sig: _visitor.fold_method_sig(_i.sig),
        default: (_i.default).map(|it| _visitor.fold_block(it)),
        semi_token: (_i.semi_token).map(|it| Token ! [ ; ](tokens_helper(_visitor, &it.spans))),
    }
}
#[cfg(feature = "full")]
pub fn fold_trait_item_type<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: TraitItemType,
) -> TraitItemType {
    TraitItemType {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        type_token: Token![type](tokens_helper(_visitor, &_i.type_token.span)),
        ident: _visitor.fold_ident(_i.ident),
        generics: _visitor.fold_generics(_i.generics),
        colon_token: (_i.colon_token).map(|it| Token ! [ : ](tokens_helper(_visitor, &it.spans))),
        bounds: FoldHelper::lift(_i.bounds, |it| _visitor.fold_type_param_bound(it)),
        default: (_i.default).map(|it| {
            (
                Token ! [ = ](tokens_helper(_visitor, &(it).0.spans)),
                _visitor.fold_type((it).1),
            )
        }),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_trait_item_verbatim<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: TraitItemVerbatim,
) -> TraitItemVerbatim {
    TraitItemVerbatim { tts: _i.tts }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type<V: Fold + ?Sized>(_visitor: &mut V, _i: Type) -> Type {
    match _i {
        Type::Slice(_binding_0) => Type::Slice(_visitor.fold_type_slice(_binding_0)),
        Type::Array(_binding_0) => Type::Array(_visitor.fold_type_array(_binding_0)),
        Type::Ptr(_binding_0) => Type::Ptr(_visitor.fold_type_ptr(_binding_0)),
        Type::Reference(_binding_0) => Type::Reference(_visitor.fold_type_reference(_binding_0)),
        Type::BareFn(_binding_0) => Type::BareFn(_visitor.fold_type_bare_fn(_binding_0)),
        Type::Never(_binding_0) => Type::Never(_visitor.fold_type_never(_binding_0)),
        Type::Tuple(_binding_0) => Type::Tuple(_visitor.fold_type_tuple(_binding_0)),
        Type::Path(_binding_0) => Type::Path(_visitor.fold_type_path(_binding_0)),
        Type::TraitObject(_binding_0) => {
            Type::TraitObject(_visitor.fold_type_trait_object(_binding_0))
        }
        Type::ImplTrait(_binding_0) => Type::ImplTrait(_visitor.fold_type_impl_trait(_binding_0)),
        Type::Paren(_binding_0) => Type::Paren(_visitor.fold_type_paren(_binding_0)),
        Type::Group(_binding_0) => Type::Group(_visitor.fold_type_group(_binding_0)),
        Type::Infer(_binding_0) => Type::Infer(_visitor.fold_type_infer(_binding_0)),
        Type::Macro(_binding_0) => Type::Macro(_visitor.fold_type_macro(_binding_0)),
        Type::Verbatim(_binding_0) => Type::Verbatim(_visitor.fold_type_verbatim(_binding_0)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_array<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeArray) -> TypeArray {
    TypeArray {
        bracket_token: Bracket(tokens_helper(_visitor, &_i.bracket_token.span)),
        elem: Box::new(_visitor.fold_type(*_i.elem)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &_i.semi_token.spans)),
        len: _visitor.fold_expr(_i.len),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_bare_fn<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeBareFn) -> TypeBareFn {
    TypeBareFn {
        lifetimes: (_i.lifetimes).map(|it| _visitor.fold_bound_lifetimes(it)),
        unsafety: (_i.unsafety).map(|it| Token![unsafe](tokens_helper(_visitor, &it.span))),
        abi: (_i.abi).map(|it| _visitor.fold_abi(it)),
        fn_token: Token![fn](tokens_helper(_visitor, &_i.fn_token.span)),
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        inputs: FoldHelper::lift(_i.inputs, |it| _visitor.fold_bare_fn_arg(it)),
        variadic: (_i.variadic).map(|it| Token ! [ ... ](tokens_helper(_visitor, &it.spans))),
        output: _visitor.fold_return_type(_i.output),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_group<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeGroup) -> TypeGroup {
    TypeGroup {
        group_token: Group(tokens_helper(_visitor, &_i.group_token.span)),
        elem: Box::new(_visitor.fold_type(*_i.elem)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_impl_trait<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: TypeImplTrait,
) -> TypeImplTrait {
    TypeImplTrait {
        impl_token: Token![impl](tokens_helper(_visitor, &_i.impl_token.span)),
        bounds: FoldHelper::lift(_i.bounds, |it| _visitor.fold_type_param_bound(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_infer<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeInfer) -> TypeInfer {
    TypeInfer {
        underscore_token: Token![_](tokens_helper(_visitor, &_i.underscore_token.spans)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_macro<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeMacro) -> TypeMacro {
    TypeMacro {
        mac: _visitor.fold_macro(_i.mac),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_never<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeNever) -> TypeNever {
    TypeNever {
        bang_token: Token![!](tokens_helper(_visitor, &_i.bang_token.spans)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_param<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeParam) -> TypeParam {
    TypeParam {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        ident: _visitor.fold_ident(_i.ident),
        colon_token: (_i.colon_token).map(|it| Token ! [ : ](tokens_helper(_visitor, &it.spans))),
        bounds: FoldHelper::lift(_i.bounds, |it| _visitor.fold_type_param_bound(it)),
        eq_token: (_i.eq_token).map(|it| Token ! [ = ](tokens_helper(_visitor, &it.spans))),
        default: (_i.default).map(|it| _visitor.fold_type(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_param_bound<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: TypeParamBound,
) -> TypeParamBound {
    match _i {
        TypeParamBound::Trait(_binding_0) => {
            TypeParamBound::Trait(_visitor.fold_trait_bound(_binding_0))
        }
        TypeParamBound::Lifetime(_binding_0) => {
            TypeParamBound::Lifetime(_visitor.fold_lifetime(_binding_0))
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_paren<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeParen) -> TypeParen {
    TypeParen {
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        elem: Box::new(_visitor.fold_type(*_i.elem)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_path<V: Fold + ?Sized>(_visitor: &mut V, _i: TypePath) -> TypePath {
    TypePath {
        qself: (_i.qself).map(|it| _visitor.fold_qself(it)),
        path: _visitor.fold_path(_i.path),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_ptr<V: Fold + ?Sized>(_visitor: &mut V, _i: TypePtr) -> TypePtr {
    TypePtr {
        star_token: Token ! [ * ](tokens_helper(_visitor, &_i.star_token.spans)),
        const_token: (_i.const_token).map(|it| Token![const](tokens_helper(_visitor, &it.span))),
        mutability: (_i.mutability).map(|it| Token![mut](tokens_helper(_visitor, &it.span))),
        elem: Box::new(_visitor.fold_type(*_i.elem)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_reference<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeReference) -> TypeReference {
    TypeReference {
        and_token: Token ! [ & ](tokens_helper(_visitor, &_i.and_token.spans)),
        lifetime: (_i.lifetime).map(|it| _visitor.fold_lifetime(it)),
        mutability: (_i.mutability).map(|it| Token![mut](tokens_helper(_visitor, &it.span))),
        elem: Box::new(_visitor.fold_type(*_i.elem)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_slice<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeSlice) -> TypeSlice {
    TypeSlice {
        bracket_token: Bracket(tokens_helper(_visitor, &_i.bracket_token.span)),
        elem: Box::new(_visitor.fold_type(*_i.elem)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_trait_object<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: TypeTraitObject,
) -> TypeTraitObject {
    TypeTraitObject {
        dyn_token: (_i.dyn_token).map(|it| Token![dyn](tokens_helper(_visitor, &it.span))),
        bounds: FoldHelper::lift(_i.bounds, |it| _visitor.fold_type_param_bound(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_tuple<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeTuple) -> TypeTuple {
    TypeTuple {
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        elems: FoldHelper::lift(_i.elems, |it| _visitor.fold_type(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_type_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeVerbatim) -> TypeVerbatim {
    TypeVerbatim { tts: _i.tts }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_un_op<V: Fold + ?Sized>(_visitor: &mut V, _i: UnOp) -> UnOp {
    match _i {
        UnOp::Deref(_binding_0) => {
            UnOp::Deref(Token ! [ * ](tokens_helper(_visitor, &_binding_0.spans)))
        }
        UnOp::Not(_binding_0) => UnOp::Not(Token![!](tokens_helper(_visitor, &_binding_0.spans))),
        UnOp::Neg(_binding_0) => {
            UnOp::Neg(Token ! [ - ](tokens_helper(_visitor, &_binding_0.spans)))
        }
    }
}
#[cfg(feature = "full")]
pub fn fold_use_glob<V: Fold + ?Sized>(_visitor: &mut V, _i: UseGlob) -> UseGlob {
    UseGlob {
        star_token: Token ! [ * ](tokens_helper(_visitor, &_i.star_token.spans)),
    }
}
#[cfg(feature = "full")]
pub fn fold_use_group<V: Fold + ?Sized>(_visitor: &mut V, _i: UseGroup) -> UseGroup {
    UseGroup {
        brace_token: Brace(tokens_helper(_visitor, &_i.brace_token.span)),
        items: FoldHelper::lift(_i.items, |it| _visitor.fold_use_tree(it)),
    }
}
#[cfg(feature = "full")]
pub fn fold_use_name<V: Fold + ?Sized>(_visitor: &mut V, _i: UseName) -> UseName {
    UseName {
        ident: _visitor.fold_ident(_i.ident),
    }
}
#[cfg(feature = "full")]
pub fn fold_use_path<V: Fold + ?Sized>(_visitor: &mut V, _i: UsePath) -> UsePath {
    UsePath {
        ident: _visitor.fold_ident(_i.ident),
        colon2_token: Token ! [ :: ](tokens_helper(_visitor, &_i.colon2_token.spans)),
        tree: Box::new(_visitor.fold_use_tree(*_i.tree)),
    }
}
#[cfg(feature = "full")]
pub fn fold_use_rename<V: Fold + ?Sized>(_visitor: &mut V, _i: UseRename) -> UseRename {
    UseRename {
        ident: _visitor.fold_ident(_i.ident),
        as_token: Token![as](tokens_helper(_visitor, &_i.as_token.span)),
        rename: _visitor.fold_ident(_i.rename),
    }
}
#[cfg(feature = "full")]
pub fn fold_use_tree<V: Fold + ?Sized>(_visitor: &mut V, _i: UseTree) -> UseTree {
    match _i {
        UseTree::Path(_binding_0) => UseTree::Path(_visitor.fold_use_path(_binding_0)),
        UseTree::Name(_binding_0) => UseTree::Name(_visitor.fold_use_name(_binding_0)),
        UseTree::Rename(_binding_0) => UseTree::Rename(_visitor.fold_use_rename(_binding_0)),
        UseTree::Glob(_binding_0) => UseTree::Glob(_visitor.fold_use_glob(_binding_0)),
        UseTree::Group(_binding_0) => UseTree::Group(_visitor.fold_use_group(_binding_0)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_variant<V: Fold + ?Sized>(_visitor: &mut V, _i: Variant) -> Variant {
    Variant {
        attrs: FoldHelper::lift(_i.attrs, |it| _visitor.fold_attribute(it)),
        ident: _visitor.fold_ident(_i.ident),
        fields: _visitor.fold_fields(_i.fields),
        discriminant: (_i.discriminant).map(|it| {
            (
                Token ! [ = ](tokens_helper(_visitor, &(it).0.spans)),
                _visitor.fold_expr((it).1),
            )
        }),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_vis_crate<V: Fold + ?Sized>(_visitor: &mut V, _i: VisCrate) -> VisCrate {
    VisCrate {
        crate_token: Token![crate](tokens_helper(_visitor, &_i.crate_token.span)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_vis_public<V: Fold + ?Sized>(_visitor: &mut V, _i: VisPublic) -> VisPublic {
    VisPublic {
        pub_token: Token![pub](tokens_helper(_visitor, &_i.pub_token.span)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_vis_restricted<V: Fold + ?Sized>(_visitor: &mut V, _i: VisRestricted) -> VisRestricted {
    VisRestricted {
        pub_token: Token![pub](tokens_helper(_visitor, &_i.pub_token.span)),
        paren_token: Paren(tokens_helper(_visitor, &_i.paren_token.span)),
        in_token: (_i.in_token).map(|it| Token![in](tokens_helper(_visitor, &it.span))),
        path: Box::new(_visitor.fold_path(*_i.path)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_visibility<V: Fold + ?Sized>(_visitor: &mut V, _i: Visibility) -> Visibility {
    match _i {
        Visibility::Public(_binding_0) => Visibility::Public(_visitor.fold_vis_public(_binding_0)),
        Visibility::Crate(_binding_0) => Visibility::Crate(_visitor.fold_vis_crate(_binding_0)),
        Visibility::Restricted(_binding_0) => {
            Visibility::Restricted(_visitor.fold_vis_restricted(_binding_0))
        }
        Visibility::Inherited => Visibility::Inherited,
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_where_clause<V: Fold + ?Sized>(_visitor: &mut V, _i: WhereClause) -> WhereClause {
    WhereClause {
        where_token: Token![where](tokens_helper(_visitor, &_i.where_token.span)),
        predicates: FoldHelper::lift(_i.predicates, |it| _visitor.fold_where_predicate(it)),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn fold_where_predicate<V: Fold + ?Sized>(
    _visitor: &mut V,
    _i: WherePredicate,
) -> WherePredicate {
    match _i {
        WherePredicate::Type(_binding_0) => {
            WherePredicate::Type(_visitor.fold_predicate_type(_binding_0))
        }
        WherePredicate::Lifetime(_binding_0) => {
            WherePredicate::Lifetime(_visitor.fold_predicate_lifetime(_binding_0))
        }
        WherePredicate::Eq(_binding_0) => {
            WherePredicate::Eq(_visitor.fold_predicate_eq(_binding_0))
        }
    }
}
pub fn fold_span<V: Fold + ?Sized>(_visitor: &mut V, _i: Span) -> Span {
    _i
}
pub fn fold_ident<V: Fold + ?Sized>(_visitor: &mut V, _i: Ident) -> Ident {
    let mut _i = _i;
    let span = _visitor.fold_span(_i.span());
    _i.set_span(span);
    _i
}
