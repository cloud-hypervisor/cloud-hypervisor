// THIS FILE IS AUTOMATICALLY GENERATED; DO NOT EDIT

#![cfg_attr(feature = "cargo-clippy", allow(trivially_copy_pass_by_ref))]
#[cfg(any(feature = "full", feature = "derive"))]
use gen::helper::visit::*;
use proc_macro2::Span;
#[cfg(any(feature = "full", feature = "derive"))]
use punctuated::Punctuated;
use *;
#[cfg(feature = "full")]
macro_rules! full {
    ($e:expr) => {
        $e
    };
}
#[cfg(all(feature = "derive", not(feature = "full")))]
macro_rules! full {
    ($e:expr) => {
        unreachable!()
    };
}
#[cfg(any(feature = "full", feature = "derive"))]
macro_rules! skip {
    ($($tt:tt)*) => {};
}
/// Syntax tree traversal to walk a shared borrow of a syntax tree.
///
/// See the [module documentation] for details.
///
/// [module documentation]: index.html
///
/// *This trait is available if Syn is built with the `"visit"` feature.*
pub trait Visit<'ast> {
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_abi(&mut self, i: &'ast Abi) {
        visit_abi(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_angle_bracketed_generic_arguments(&mut self, i: &'ast AngleBracketedGenericArguments) {
        visit_angle_bracketed_generic_arguments(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_arg_captured(&mut self, i: &'ast ArgCaptured) {
        visit_arg_captured(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_arg_self(&mut self, i: &'ast ArgSelf) {
        visit_arg_self(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_arg_self_ref(&mut self, i: &'ast ArgSelfRef) {
        visit_arg_self_ref(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_arm(&mut self, i: &'ast Arm) {
        visit_arm(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_attr_style(&mut self, i: &'ast AttrStyle) {
        visit_attr_style(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_attribute(&mut self, i: &'ast Attribute) {
        visit_attribute(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_bare_fn_arg(&mut self, i: &'ast BareFnArg) {
        visit_bare_fn_arg(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_bare_fn_arg_name(&mut self, i: &'ast BareFnArgName) {
        visit_bare_fn_arg_name(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_bin_op(&mut self, i: &'ast BinOp) {
        visit_bin_op(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_binding(&mut self, i: &'ast Binding) {
        visit_binding(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_block(&mut self, i: &'ast Block) {
        visit_block(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_bound_lifetimes(&mut self, i: &'ast BoundLifetimes) {
        visit_bound_lifetimes(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_const_param(&mut self, i: &'ast ConstParam) {
        visit_const_param(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_constraint(&mut self, i: &'ast Constraint) {
        visit_constraint(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_data(&mut self, i: &'ast Data) {
        visit_data(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_data_enum(&mut self, i: &'ast DataEnum) {
        visit_data_enum(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_data_struct(&mut self, i: &'ast DataStruct) {
        visit_data_struct(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_data_union(&mut self, i: &'ast DataUnion) {
        visit_data_union(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_derive_input(&mut self, i: &'ast DeriveInput) {
        visit_derive_input(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr(&mut self, i: &'ast Expr) {
        visit_expr(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_array(&mut self, i: &'ast ExprArray) {
        visit_expr_array(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_assign(&mut self, i: &'ast ExprAssign) {
        visit_expr_assign(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_assign_op(&mut self, i: &'ast ExprAssignOp) {
        visit_expr_assign_op(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_async(&mut self, i: &'ast ExprAsync) {
        visit_expr_async(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_binary(&mut self, i: &'ast ExprBinary) {
        visit_expr_binary(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_block(&mut self, i: &'ast ExprBlock) {
        visit_expr_block(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_box(&mut self, i: &'ast ExprBox) {
        visit_expr_box(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_break(&mut self, i: &'ast ExprBreak) {
        visit_expr_break(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_call(&mut self, i: &'ast ExprCall) {
        visit_expr_call(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_cast(&mut self, i: &'ast ExprCast) {
        visit_expr_cast(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_closure(&mut self, i: &'ast ExprClosure) {
        visit_expr_closure(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_continue(&mut self, i: &'ast ExprContinue) {
        visit_expr_continue(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_field(&mut self, i: &'ast ExprField) {
        visit_expr_field(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_for_loop(&mut self, i: &'ast ExprForLoop) {
        visit_expr_for_loop(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_group(&mut self, i: &'ast ExprGroup) {
        visit_expr_group(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_if(&mut self, i: &'ast ExprIf) {
        visit_expr_if(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_in_place(&mut self, i: &'ast ExprInPlace) {
        visit_expr_in_place(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_index(&mut self, i: &'ast ExprIndex) {
        visit_expr_index(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_let(&mut self, i: &'ast ExprLet) {
        visit_expr_let(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_lit(&mut self, i: &'ast ExprLit) {
        visit_expr_lit(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_loop(&mut self, i: &'ast ExprLoop) {
        visit_expr_loop(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_macro(&mut self, i: &'ast ExprMacro) {
        visit_expr_macro(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_match(&mut self, i: &'ast ExprMatch) {
        visit_expr_match(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_method_call(&mut self, i: &'ast ExprMethodCall) {
        visit_expr_method_call(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_paren(&mut self, i: &'ast ExprParen) {
        visit_expr_paren(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_path(&mut self, i: &'ast ExprPath) {
        visit_expr_path(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_range(&mut self, i: &'ast ExprRange) {
        visit_expr_range(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_reference(&mut self, i: &'ast ExprReference) {
        visit_expr_reference(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_repeat(&mut self, i: &'ast ExprRepeat) {
        visit_expr_repeat(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_return(&mut self, i: &'ast ExprReturn) {
        visit_expr_return(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_struct(&mut self, i: &'ast ExprStruct) {
        visit_expr_struct(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_try(&mut self, i: &'ast ExprTry) {
        visit_expr_try(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_try_block(&mut self, i: &'ast ExprTryBlock) {
        visit_expr_try_block(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_tuple(&mut self, i: &'ast ExprTuple) {
        visit_expr_tuple(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_type(&mut self, i: &'ast ExprType) {
        visit_expr_type(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_unary(&mut self, i: &'ast ExprUnary) {
        visit_expr_unary(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_unsafe(&mut self, i: &'ast ExprUnsafe) {
        visit_expr_unsafe(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_verbatim(&mut self, i: &'ast ExprVerbatim) {
        visit_expr_verbatim(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_while(&mut self, i: &'ast ExprWhile) {
        visit_expr_while(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_yield(&mut self, i: &'ast ExprYield) {
        visit_expr_yield(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_field(&mut self, i: &'ast Field) {
        visit_field(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_field_pat(&mut self, i: &'ast FieldPat) {
        visit_field_pat(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_field_value(&mut self, i: &'ast FieldValue) {
        visit_field_value(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_fields(&mut self, i: &'ast Fields) {
        visit_fields(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_fields_named(&mut self, i: &'ast FieldsNamed) {
        visit_fields_named(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_fields_unnamed(&mut self, i: &'ast FieldsUnnamed) {
        visit_fields_unnamed(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_file(&mut self, i: &'ast File) {
        visit_file(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_fn_arg(&mut self, i: &'ast FnArg) {
        visit_fn_arg(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_fn_decl(&mut self, i: &'ast FnDecl) {
        visit_fn_decl(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item(&mut self, i: &'ast ForeignItem) {
        visit_foreign_item(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_fn(&mut self, i: &'ast ForeignItemFn) {
        visit_foreign_item_fn(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_macro(&mut self, i: &'ast ForeignItemMacro) {
        visit_foreign_item_macro(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_static(&mut self, i: &'ast ForeignItemStatic) {
        visit_foreign_item_static(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_type(&mut self, i: &'ast ForeignItemType) {
        visit_foreign_item_type(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_verbatim(&mut self, i: &'ast ForeignItemVerbatim) {
        visit_foreign_item_verbatim(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_generic_argument(&mut self, i: &'ast GenericArgument) {
        visit_generic_argument(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_generic_method_argument(&mut self, i: &'ast GenericMethodArgument) {
        visit_generic_method_argument(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_generic_param(&mut self, i: &'ast GenericParam) {
        visit_generic_param(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_generics(&mut self, i: &'ast Generics) {
        visit_generics(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item(&mut self, i: &'ast ImplItem) {
        visit_impl_item(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_const(&mut self, i: &'ast ImplItemConst) {
        visit_impl_item_const(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_existential(&mut self, i: &'ast ImplItemExistential) {
        visit_impl_item_existential(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_macro(&mut self, i: &'ast ImplItemMacro) {
        visit_impl_item_macro(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_method(&mut self, i: &'ast ImplItemMethod) {
        visit_impl_item_method(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_type(&mut self, i: &'ast ImplItemType) {
        visit_impl_item_type(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_verbatim(&mut self, i: &'ast ImplItemVerbatim) {
        visit_impl_item_verbatim(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_index(&mut self, i: &'ast Index) {
        visit_index(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item(&mut self, i: &'ast Item) {
        visit_item(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_const(&mut self, i: &'ast ItemConst) {
        visit_item_const(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_enum(&mut self, i: &'ast ItemEnum) {
        visit_item_enum(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_existential(&mut self, i: &'ast ItemExistential) {
        visit_item_existential(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_extern_crate(&mut self, i: &'ast ItemExternCrate) {
        visit_item_extern_crate(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_fn(&mut self, i: &'ast ItemFn) {
        visit_item_fn(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_foreign_mod(&mut self, i: &'ast ItemForeignMod) {
        visit_item_foreign_mod(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_impl(&mut self, i: &'ast ItemImpl) {
        visit_item_impl(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_macro(&mut self, i: &'ast ItemMacro) {
        visit_item_macro(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_macro2(&mut self, i: &'ast ItemMacro2) {
        visit_item_macro2(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_mod(&mut self, i: &'ast ItemMod) {
        visit_item_mod(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_static(&mut self, i: &'ast ItemStatic) {
        visit_item_static(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_struct(&mut self, i: &'ast ItemStruct) {
        visit_item_struct(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_trait(&mut self, i: &'ast ItemTrait) {
        visit_item_trait(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_trait_alias(&mut self, i: &'ast ItemTraitAlias) {
        visit_item_trait_alias(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_type(&mut self, i: &'ast ItemType) {
        visit_item_type(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_union(&mut self, i: &'ast ItemUnion) {
        visit_item_union(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_use(&mut self, i: &'ast ItemUse) {
        visit_item_use(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_verbatim(&mut self, i: &'ast ItemVerbatim) {
        visit_item_verbatim(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_label(&mut self, i: &'ast Label) {
        visit_label(self, i)
    }
    fn visit_lifetime(&mut self, i: &'ast Lifetime) {
        visit_lifetime(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lifetime_def(&mut self, i: &'ast LifetimeDef) {
        visit_lifetime_def(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit(&mut self, i: &'ast Lit) {
        visit_lit(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_bool(&mut self, i: &'ast LitBool) {
        visit_lit_bool(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_byte(&mut self, i: &'ast LitByte) {
        visit_lit_byte(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_byte_str(&mut self, i: &'ast LitByteStr) {
        visit_lit_byte_str(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_char(&mut self, i: &'ast LitChar) {
        visit_lit_char(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_float(&mut self, i: &'ast LitFloat) {
        visit_lit_float(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_int(&mut self, i: &'ast LitInt) {
        visit_lit_int(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_str(&mut self, i: &'ast LitStr) {
        visit_lit_str(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_verbatim(&mut self, i: &'ast LitVerbatim) {
        visit_lit_verbatim(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_local(&mut self, i: &'ast Local) {
        visit_local(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_macro(&mut self, i: &'ast Macro) {
        visit_macro(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_macro_delimiter(&mut self, i: &'ast MacroDelimiter) {
        visit_macro_delimiter(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_member(&mut self, i: &'ast Member) {
        visit_member(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_meta(&mut self, i: &'ast Meta) {
        visit_meta(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_meta_list(&mut self, i: &'ast MetaList) {
        visit_meta_list(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_meta_name_value(&mut self, i: &'ast MetaNameValue) {
        visit_meta_name_value(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_method_sig(&mut self, i: &'ast MethodSig) {
        visit_method_sig(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_method_turbofish(&mut self, i: &'ast MethodTurbofish) {
        visit_method_turbofish(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_nested_meta(&mut self, i: &'ast NestedMeta) {
        visit_nested_meta(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_parenthesized_generic_arguments(&mut self, i: &'ast ParenthesizedGenericArguments) {
        visit_parenthesized_generic_arguments(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat(&mut self, i: &'ast Pat) {
        visit_pat(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_box(&mut self, i: &'ast PatBox) {
        visit_pat_box(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_ident(&mut self, i: &'ast PatIdent) {
        visit_pat_ident(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_lit(&mut self, i: &'ast PatLit) {
        visit_pat_lit(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_macro(&mut self, i: &'ast PatMacro) {
        visit_pat_macro(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_path(&mut self, i: &'ast PatPath) {
        visit_pat_path(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_range(&mut self, i: &'ast PatRange) {
        visit_pat_range(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_ref(&mut self, i: &'ast PatRef) {
        visit_pat_ref(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_slice(&mut self, i: &'ast PatSlice) {
        visit_pat_slice(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_struct(&mut self, i: &'ast PatStruct) {
        visit_pat_struct(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_tuple(&mut self, i: &'ast PatTuple) {
        visit_pat_tuple(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_tuple_struct(&mut self, i: &'ast PatTupleStruct) {
        visit_pat_tuple_struct(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_verbatim(&mut self, i: &'ast PatVerbatim) {
        visit_pat_verbatim(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_wild(&mut self, i: &'ast PatWild) {
        visit_pat_wild(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_path(&mut self, i: &'ast Path) {
        visit_path(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_path_arguments(&mut self, i: &'ast PathArguments) {
        visit_path_arguments(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_path_segment(&mut self, i: &'ast PathSegment) {
        visit_path_segment(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_predicate_eq(&mut self, i: &'ast PredicateEq) {
        visit_predicate_eq(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_predicate_lifetime(&mut self, i: &'ast PredicateLifetime) {
        visit_predicate_lifetime(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_predicate_type(&mut self, i: &'ast PredicateType) {
        visit_predicate_type(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_qself(&mut self, i: &'ast QSelf) {
        visit_qself(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_range_limits(&mut self, i: &'ast RangeLimits) {
        visit_range_limits(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_return_type(&mut self, i: &'ast ReturnType) {
        visit_return_type(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_stmt(&mut self, i: &'ast Stmt) {
        visit_stmt(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_trait_bound(&mut self, i: &'ast TraitBound) {
        visit_trait_bound(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_trait_bound_modifier(&mut self, i: &'ast TraitBoundModifier) {
        visit_trait_bound_modifier(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item(&mut self, i: &'ast TraitItem) {
        visit_trait_item(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_const(&mut self, i: &'ast TraitItemConst) {
        visit_trait_item_const(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_macro(&mut self, i: &'ast TraitItemMacro) {
        visit_trait_item_macro(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_method(&mut self, i: &'ast TraitItemMethod) {
        visit_trait_item_method(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_type(&mut self, i: &'ast TraitItemType) {
        visit_trait_item_type(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_verbatim(&mut self, i: &'ast TraitItemVerbatim) {
        visit_trait_item_verbatim(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type(&mut self, i: &'ast Type) {
        visit_type(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_array(&mut self, i: &'ast TypeArray) {
        visit_type_array(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_bare_fn(&mut self, i: &'ast TypeBareFn) {
        visit_type_bare_fn(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_group(&mut self, i: &'ast TypeGroup) {
        visit_type_group(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_impl_trait(&mut self, i: &'ast TypeImplTrait) {
        visit_type_impl_trait(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_infer(&mut self, i: &'ast TypeInfer) {
        visit_type_infer(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_macro(&mut self, i: &'ast TypeMacro) {
        visit_type_macro(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_never(&mut self, i: &'ast TypeNever) {
        visit_type_never(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_param(&mut self, i: &'ast TypeParam) {
        visit_type_param(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_param_bound(&mut self, i: &'ast TypeParamBound) {
        visit_type_param_bound(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_paren(&mut self, i: &'ast TypeParen) {
        visit_type_paren(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_path(&mut self, i: &'ast TypePath) {
        visit_type_path(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_ptr(&mut self, i: &'ast TypePtr) {
        visit_type_ptr(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_reference(&mut self, i: &'ast TypeReference) {
        visit_type_reference(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_slice(&mut self, i: &'ast TypeSlice) {
        visit_type_slice(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_trait_object(&mut self, i: &'ast TypeTraitObject) {
        visit_type_trait_object(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_tuple(&mut self, i: &'ast TypeTuple) {
        visit_type_tuple(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_verbatim(&mut self, i: &'ast TypeVerbatim) {
        visit_type_verbatim(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_un_op(&mut self, i: &'ast UnOp) {
        visit_un_op(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_glob(&mut self, i: &'ast UseGlob) {
        visit_use_glob(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_group(&mut self, i: &'ast UseGroup) {
        visit_use_group(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_name(&mut self, i: &'ast UseName) {
        visit_use_name(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_path(&mut self, i: &'ast UsePath) {
        visit_use_path(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_rename(&mut self, i: &'ast UseRename) {
        visit_use_rename(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_tree(&mut self, i: &'ast UseTree) {
        visit_use_tree(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_variant(&mut self, i: &'ast Variant) {
        visit_variant(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_vis_crate(&mut self, i: &'ast VisCrate) {
        visit_vis_crate(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_vis_public(&mut self, i: &'ast VisPublic) {
        visit_vis_public(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_vis_restricted(&mut self, i: &'ast VisRestricted) {
        visit_vis_restricted(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_visibility(&mut self, i: &'ast Visibility) {
        visit_visibility(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_where_clause(&mut self, i: &'ast WhereClause) {
        visit_where_clause(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_where_predicate(&mut self, i: &'ast WherePredicate) {
        visit_where_predicate(self, i)
    }
    fn visit_span(&mut self, i: &'ast Span) {
        visit_span(self, i)
    }
    fn visit_ident(&mut self, i: &'ast Ident) {
        visit_ident(self, i)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_abi<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Abi) {
    tokens_helper(_visitor, &_i.extern_token.span);
    if let Some(ref it) = _i.name {
        _visitor.visit_lit_str(it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_angle_bracketed_generic_arguments<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast AngleBracketedGenericArguments,
) {
    if let Some(ref it) = _i.colon2_token {
        tokens_helper(_visitor, &it.spans)
    };
    tokens_helper(_visitor, &_i.lt_token.spans);
    for el in Punctuated::pairs(&_i.args) {
        let it = el.value();
        _visitor.visit_generic_argument(it)
    }
    tokens_helper(_visitor, &_i.gt_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_arg_captured<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ArgCaptured) {
    _visitor.visit_pat(&_i.pat);
    tokens_helper(_visitor, &_i.colon_token.spans);
    _visitor.visit_type(&_i.ty);
}
#[cfg(feature = "full")]
pub fn visit_arg_self<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ArgSelf) {
    if let Some(ref it) = _i.mutability {
        tokens_helper(_visitor, &it.span)
    };
    tokens_helper(_visitor, &_i.self_token.span);
}
#[cfg(feature = "full")]
pub fn visit_arg_self_ref<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ArgSelfRef) {
    tokens_helper(_visitor, &_i.and_token.spans);
    if let Some(ref it) = _i.lifetime {
        _visitor.visit_lifetime(it)
    };
    if let Some(ref it) = _i.mutability {
        tokens_helper(_visitor, &it.span)
    };
    tokens_helper(_visitor, &_i.self_token.span);
}
#[cfg(feature = "full")]
pub fn visit_arm<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Arm) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    if let Some(ref it) = _i.leading_vert {
        tokens_helper(_visitor, &it.spans)
    };
    for el in Punctuated::pairs(&_i.pats) {
        let it = el.value();
        _visitor.visit_pat(it)
    }
    if let Some(ref it) = _i.guard {
        tokens_helper(_visitor, &(it).0.span);
        _visitor.visit_expr(&*(it).1);
    };
    tokens_helper(_visitor, &_i.fat_arrow_token.spans);
    _visitor.visit_expr(&*_i.body);
    if let Some(ref it) = _i.comma {
        tokens_helper(_visitor, &it.spans)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_attr_style<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast AttrStyle) {
    match *_i {
        AttrStyle::Outer => {}
        AttrStyle::Inner(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_attribute<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Attribute) {
    tokens_helper(_visitor, &_i.pound_token.spans);
    _visitor.visit_attr_style(&_i.style);
    tokens_helper(_visitor, &_i.bracket_token.span);
    _visitor.visit_path(&_i.path);
    skip!(_i.tts);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_bare_fn_arg<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast BareFnArg) {
    if let Some(ref it) = _i.name {
        _visitor.visit_bare_fn_arg_name(&(it).0);
        tokens_helper(_visitor, &(it).1.spans);
    };
    _visitor.visit_type(&_i.ty);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_bare_fn_arg_name<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast BareFnArgName,
) {
    match *_i {
        BareFnArgName::Named(ref _binding_0) => {
            _visitor.visit_ident(_binding_0);
        }
        BareFnArgName::Wild(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_bin_op<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast BinOp) {
    match *_i {
        BinOp::Add(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Sub(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Mul(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Div(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Rem(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::And(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Or(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::BitXor(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::BitAnd(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::BitOr(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Shl(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Shr(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Eq(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Lt(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Le(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Ne(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Ge(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::Gt(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::AddEq(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::SubEq(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::MulEq(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::DivEq(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::RemEq(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::BitXorEq(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::BitAndEq(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::BitOrEq(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::ShlEq(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        BinOp::ShrEq(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_binding<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Binding) {
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.eq_token.spans);
    _visitor.visit_type(&_i.ty);
}
#[cfg(feature = "full")]
pub fn visit_block<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Block) {
    tokens_helper(_visitor, &_i.brace_token.span);
    for it in &_i.stmts {
        _visitor.visit_stmt(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_bound_lifetimes<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast BoundLifetimes,
) {
    tokens_helper(_visitor, &_i.for_token.span);
    tokens_helper(_visitor, &_i.lt_token.spans);
    for el in Punctuated::pairs(&_i.lifetimes) {
        let it = el.value();
        _visitor.visit_lifetime_def(it)
    }
    tokens_helper(_visitor, &_i.gt_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_const_param<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ConstParam) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.const_token.span);
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.colon_token.spans);
    _visitor.visit_type(&_i.ty);
    if let Some(ref it) = _i.eq_token {
        tokens_helper(_visitor, &it.spans)
    };
    if let Some(ref it) = _i.default {
        _visitor.visit_expr(it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_constraint<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Constraint) {
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.colon_token.spans);
    for el in Punctuated::pairs(&_i.bounds) {
        let it = el.value();
        _visitor.visit_type_param_bound(it)
    }
}
#[cfg(feature = "derive")]
pub fn visit_data<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Data) {
    match *_i {
        Data::Struct(ref _binding_0) => {
            _visitor.visit_data_struct(_binding_0);
        }
        Data::Enum(ref _binding_0) => {
            _visitor.visit_data_enum(_binding_0);
        }
        Data::Union(ref _binding_0) => {
            _visitor.visit_data_union(_binding_0);
        }
    }
}
#[cfg(feature = "derive")]
pub fn visit_data_enum<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast DataEnum) {
    tokens_helper(_visitor, &_i.enum_token.span);
    tokens_helper(_visitor, &_i.brace_token.span);
    for el in Punctuated::pairs(&_i.variants) {
        let it = el.value();
        _visitor.visit_variant(it)
    }
}
#[cfg(feature = "derive")]
pub fn visit_data_struct<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast DataStruct) {
    tokens_helper(_visitor, &_i.struct_token.span);
    _visitor.visit_fields(&_i.fields);
    if let Some(ref it) = _i.semi_token {
        tokens_helper(_visitor, &it.spans)
    };
}
#[cfg(feature = "derive")]
pub fn visit_data_union<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast DataUnion) {
    tokens_helper(_visitor, &_i.union_token.span);
    _visitor.visit_fields_named(&_i.fields);
}
#[cfg(feature = "derive")]
pub fn visit_derive_input<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast DeriveInput) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_generics(&_i.generics);
    _visitor.visit_data(&_i.data);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Expr) {
    match *_i {
        Expr::Box(ref _binding_0) => {
            full!(_visitor.visit_expr_box(_binding_0));
        }
        Expr::InPlace(ref _binding_0) => {
            full!(_visitor.visit_expr_in_place(_binding_0));
        }
        Expr::Array(ref _binding_0) => {
            full!(_visitor.visit_expr_array(_binding_0));
        }
        Expr::Call(ref _binding_0) => {
            _visitor.visit_expr_call(_binding_0);
        }
        Expr::MethodCall(ref _binding_0) => {
            full!(_visitor.visit_expr_method_call(_binding_0));
        }
        Expr::Tuple(ref _binding_0) => {
            full!(_visitor.visit_expr_tuple(_binding_0));
        }
        Expr::Binary(ref _binding_0) => {
            _visitor.visit_expr_binary(_binding_0);
        }
        Expr::Unary(ref _binding_0) => {
            _visitor.visit_expr_unary(_binding_0);
        }
        Expr::Lit(ref _binding_0) => {
            _visitor.visit_expr_lit(_binding_0);
        }
        Expr::Cast(ref _binding_0) => {
            _visitor.visit_expr_cast(_binding_0);
        }
        Expr::Type(ref _binding_0) => {
            full!(_visitor.visit_expr_type(_binding_0));
        }
        Expr::Let(ref _binding_0) => {
            full!(_visitor.visit_expr_let(_binding_0));
        }
        Expr::If(ref _binding_0) => {
            full!(_visitor.visit_expr_if(_binding_0));
        }
        Expr::While(ref _binding_0) => {
            full!(_visitor.visit_expr_while(_binding_0));
        }
        Expr::ForLoop(ref _binding_0) => {
            full!(_visitor.visit_expr_for_loop(_binding_0));
        }
        Expr::Loop(ref _binding_0) => {
            full!(_visitor.visit_expr_loop(_binding_0));
        }
        Expr::Match(ref _binding_0) => {
            full!(_visitor.visit_expr_match(_binding_0));
        }
        Expr::Closure(ref _binding_0) => {
            full!(_visitor.visit_expr_closure(_binding_0));
        }
        Expr::Unsafe(ref _binding_0) => {
            full!(_visitor.visit_expr_unsafe(_binding_0));
        }
        Expr::Block(ref _binding_0) => {
            full!(_visitor.visit_expr_block(_binding_0));
        }
        Expr::Assign(ref _binding_0) => {
            full!(_visitor.visit_expr_assign(_binding_0));
        }
        Expr::AssignOp(ref _binding_0) => {
            full!(_visitor.visit_expr_assign_op(_binding_0));
        }
        Expr::Field(ref _binding_0) => {
            _visitor.visit_expr_field(_binding_0);
        }
        Expr::Index(ref _binding_0) => {
            _visitor.visit_expr_index(_binding_0);
        }
        Expr::Range(ref _binding_0) => {
            full!(_visitor.visit_expr_range(_binding_0));
        }
        Expr::Path(ref _binding_0) => {
            _visitor.visit_expr_path(_binding_0);
        }
        Expr::Reference(ref _binding_0) => {
            full!(_visitor.visit_expr_reference(_binding_0));
        }
        Expr::Break(ref _binding_0) => {
            full!(_visitor.visit_expr_break(_binding_0));
        }
        Expr::Continue(ref _binding_0) => {
            full!(_visitor.visit_expr_continue(_binding_0));
        }
        Expr::Return(ref _binding_0) => {
            full!(_visitor.visit_expr_return(_binding_0));
        }
        Expr::Macro(ref _binding_0) => {
            full!(_visitor.visit_expr_macro(_binding_0));
        }
        Expr::Struct(ref _binding_0) => {
            full!(_visitor.visit_expr_struct(_binding_0));
        }
        Expr::Repeat(ref _binding_0) => {
            full!(_visitor.visit_expr_repeat(_binding_0));
        }
        Expr::Paren(ref _binding_0) => {
            _visitor.visit_expr_paren(_binding_0);
        }
        Expr::Group(ref _binding_0) => {
            full!(_visitor.visit_expr_group(_binding_0));
        }
        Expr::Try(ref _binding_0) => {
            full!(_visitor.visit_expr_try(_binding_0));
        }
        Expr::Async(ref _binding_0) => {
            full!(_visitor.visit_expr_async(_binding_0));
        }
        Expr::TryBlock(ref _binding_0) => {
            full!(_visitor.visit_expr_try_block(_binding_0));
        }
        Expr::Yield(ref _binding_0) => {
            full!(_visitor.visit_expr_yield(_binding_0));
        }
        Expr::Verbatim(ref _binding_0) => {
            _visitor.visit_expr_verbatim(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_expr_array<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprArray) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.bracket_token.span);
    for el in Punctuated::pairs(&_i.elems) {
        let it = el.value();
        _visitor.visit_expr(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_expr_assign<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprAssign) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_expr(&*_i.left);
    tokens_helper(_visitor, &_i.eq_token.spans);
    _visitor.visit_expr(&*_i.right);
}
#[cfg(feature = "full")]
pub fn visit_expr_assign_op<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ExprAssignOp,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_expr(&*_i.left);
    _visitor.visit_bin_op(&_i.op);
    _visitor.visit_expr(&*_i.right);
}
#[cfg(feature = "full")]
pub fn visit_expr_async<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprAsync) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.async_token.span);
    if let Some(ref it) = _i.capture {
        tokens_helper(_visitor, &it.span)
    };
    _visitor.visit_block(&_i.block);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_binary<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprBinary) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_expr(&*_i.left);
    _visitor.visit_bin_op(&_i.op);
    _visitor.visit_expr(&*_i.right);
}
#[cfg(feature = "full")]
pub fn visit_expr_block<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprBlock) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    if let Some(ref it) = _i.label {
        _visitor.visit_label(it)
    };
    _visitor.visit_block(&_i.block);
}
#[cfg(feature = "full")]
pub fn visit_expr_box<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprBox) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.box_token.span);
    _visitor.visit_expr(&*_i.expr);
}
#[cfg(feature = "full")]
pub fn visit_expr_break<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprBreak) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.break_token.span);
    if let Some(ref it) = _i.label {
        _visitor.visit_lifetime(it)
    };
    if let Some(ref it) = _i.expr {
        _visitor.visit_expr(&**it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_call<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprCall) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_expr(&*_i.func);
    tokens_helper(_visitor, &_i.paren_token.span);
    for el in Punctuated::pairs(&_i.args) {
        let it = el.value();
        _visitor.visit_expr(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_cast<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprCast) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_expr(&*_i.expr);
    tokens_helper(_visitor, &_i.as_token.span);
    _visitor.visit_type(&*_i.ty);
}
#[cfg(feature = "full")]
pub fn visit_expr_closure<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprClosure) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    if let Some(ref it) = _i.asyncness {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.movability {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.capture {
        tokens_helper(_visitor, &it.span)
    };
    tokens_helper(_visitor, &_i.or1_token.spans);
    for el in Punctuated::pairs(&_i.inputs) {
        let it = el.value();
        _visitor.visit_fn_arg(it)
    }
    tokens_helper(_visitor, &_i.or2_token.spans);
    _visitor.visit_return_type(&_i.output);
    _visitor.visit_expr(&*_i.body);
}
#[cfg(feature = "full")]
pub fn visit_expr_continue<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ExprContinue,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.continue_token.span);
    if let Some(ref it) = _i.label {
        _visitor.visit_lifetime(it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_field<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprField) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_expr(&*_i.base);
    tokens_helper(_visitor, &_i.dot_token.spans);
    _visitor.visit_member(&_i.member);
}
#[cfg(feature = "full")]
pub fn visit_expr_for_loop<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprForLoop) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    if let Some(ref it) = _i.label {
        _visitor.visit_label(it)
    };
    tokens_helper(_visitor, &_i.for_token.span);
    _visitor.visit_pat(&*_i.pat);
    tokens_helper(_visitor, &_i.in_token.span);
    _visitor.visit_expr(&*_i.expr);
    _visitor.visit_block(&_i.body);
}
#[cfg(feature = "full")]
pub fn visit_expr_group<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprGroup) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.group_token.span);
    _visitor.visit_expr(&*_i.expr);
}
#[cfg(feature = "full")]
pub fn visit_expr_if<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprIf) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.if_token.span);
    _visitor.visit_expr(&*_i.cond);
    _visitor.visit_block(&_i.then_branch);
    if let Some(ref it) = _i.else_branch {
        tokens_helper(_visitor, &(it).0.span);
        _visitor.visit_expr(&*(it).1);
    };
}
#[cfg(feature = "full")]
pub fn visit_expr_in_place<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprInPlace) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_expr(&*_i.place);
    tokens_helper(_visitor, &_i.arrow_token.spans);
    _visitor.visit_expr(&*_i.value);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_index<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprIndex) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_expr(&*_i.expr);
    tokens_helper(_visitor, &_i.bracket_token.span);
    _visitor.visit_expr(&*_i.index);
}
#[cfg(feature = "full")]
pub fn visit_expr_let<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprLet) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.let_token.span);
    for el in Punctuated::pairs(&_i.pats) {
        let it = el.value();
        _visitor.visit_pat(it)
    }
    tokens_helper(_visitor, &_i.eq_token.spans);
    _visitor.visit_expr(&*_i.expr);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_lit<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprLit) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_lit(&_i.lit);
}
#[cfg(feature = "full")]
pub fn visit_expr_loop<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprLoop) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    if let Some(ref it) = _i.label {
        _visitor.visit_label(it)
    };
    tokens_helper(_visitor, &_i.loop_token.span);
    _visitor.visit_block(&_i.body);
}
#[cfg(feature = "full")]
pub fn visit_expr_macro<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprMacro) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_macro(&_i.mac);
}
#[cfg(feature = "full")]
pub fn visit_expr_match<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprMatch) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.match_token.span);
    _visitor.visit_expr(&*_i.expr);
    tokens_helper(_visitor, &_i.brace_token.span);
    for it in &_i.arms {
        _visitor.visit_arm(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_expr_method_call<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ExprMethodCall,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_expr(&*_i.receiver);
    tokens_helper(_visitor, &_i.dot_token.spans);
    _visitor.visit_ident(&_i.method);
    if let Some(ref it) = _i.turbofish {
        _visitor.visit_method_turbofish(it)
    };
    tokens_helper(_visitor, &_i.paren_token.span);
    for el in Punctuated::pairs(&_i.args) {
        let it = el.value();
        _visitor.visit_expr(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_paren<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprParen) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.paren_token.span);
    _visitor.visit_expr(&*_i.expr);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_path<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprPath) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    if let Some(ref it) = _i.qself {
        _visitor.visit_qself(it)
    };
    _visitor.visit_path(&_i.path);
}
#[cfg(feature = "full")]
pub fn visit_expr_range<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprRange) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    if let Some(ref it) = _i.from {
        _visitor.visit_expr(&**it)
    };
    _visitor.visit_range_limits(&_i.limits);
    if let Some(ref it) = _i.to {
        _visitor.visit_expr(&**it)
    };
}
#[cfg(feature = "full")]
pub fn visit_expr_reference<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ExprReference,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.and_token.spans);
    if let Some(ref it) = _i.mutability {
        tokens_helper(_visitor, &it.span)
    };
    _visitor.visit_expr(&*_i.expr);
}
#[cfg(feature = "full")]
pub fn visit_expr_repeat<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprRepeat) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.bracket_token.span);
    _visitor.visit_expr(&*_i.expr);
    tokens_helper(_visitor, &_i.semi_token.spans);
    _visitor.visit_expr(&*_i.len);
}
#[cfg(feature = "full")]
pub fn visit_expr_return<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprReturn) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.return_token.span);
    if let Some(ref it) = _i.expr {
        _visitor.visit_expr(&**it)
    };
}
#[cfg(feature = "full")]
pub fn visit_expr_struct<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprStruct) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_path(&_i.path);
    tokens_helper(_visitor, &_i.brace_token.span);
    for el in Punctuated::pairs(&_i.fields) {
        let it = el.value();
        _visitor.visit_field_value(it)
    }
    if let Some(ref it) = _i.dot2_token {
        tokens_helper(_visitor, &it.spans)
    };
    if let Some(ref it) = _i.rest {
        _visitor.visit_expr(&**it)
    };
}
#[cfg(feature = "full")]
pub fn visit_expr_try<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprTry) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_expr(&*_i.expr);
    tokens_helper(_visitor, &_i.question_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_expr_try_block<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ExprTryBlock,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.try_token.span);
    _visitor.visit_block(&_i.block);
}
#[cfg(feature = "full")]
pub fn visit_expr_tuple<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprTuple) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.paren_token.span);
    for el in Punctuated::pairs(&_i.elems) {
        let it = el.value();
        _visitor.visit_expr(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_expr_type<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprType) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_expr(&*_i.expr);
    tokens_helper(_visitor, &_i.colon_token.spans);
    _visitor.visit_type(&*_i.ty);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_unary<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprUnary) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_un_op(&_i.op);
    _visitor.visit_expr(&*_i.expr);
}
#[cfg(feature = "full")]
pub fn visit_expr_unsafe<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprUnsafe) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.unsafe_token.span);
    _visitor.visit_block(&_i.block);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_verbatim<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ExprVerbatim,
) {
    skip!(_i.tts);
}
#[cfg(feature = "full")]
pub fn visit_expr_while<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprWhile) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    if let Some(ref it) = _i.label {
        _visitor.visit_label(it)
    };
    tokens_helper(_visitor, &_i.while_token.span);
    _visitor.visit_expr(&*_i.cond);
    _visitor.visit_block(&_i.body);
}
#[cfg(feature = "full")]
pub fn visit_expr_yield<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprYield) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.yield_token.span);
    if let Some(ref it) = _i.expr {
        _visitor.visit_expr(&**it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_field<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Field) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    if let Some(ref it) = _i.ident {
        _visitor.visit_ident(it)
    };
    if let Some(ref it) = _i.colon_token {
        tokens_helper(_visitor, &it.spans)
    };
    _visitor.visit_type(&_i.ty);
}
#[cfg(feature = "full")]
pub fn visit_field_pat<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast FieldPat) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_member(&_i.member);
    if let Some(ref it) = _i.colon_token {
        tokens_helper(_visitor, &it.spans)
    };
    _visitor.visit_pat(&*_i.pat);
}
#[cfg(feature = "full")]
pub fn visit_field_value<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast FieldValue) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_member(&_i.member);
    if let Some(ref it) = _i.colon_token {
        tokens_helper(_visitor, &it.spans)
    };
    _visitor.visit_expr(&_i.expr);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_fields<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Fields) {
    match *_i {
        Fields::Named(ref _binding_0) => {
            _visitor.visit_fields_named(_binding_0);
        }
        Fields::Unnamed(ref _binding_0) => {
            _visitor.visit_fields_unnamed(_binding_0);
        }
        Fields::Unit => {}
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_fields_named<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast FieldsNamed) {
    tokens_helper(_visitor, &_i.brace_token.span);
    for el in Punctuated::pairs(&_i.named) {
        let it = el.value();
        _visitor.visit_field(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_fields_unnamed<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast FieldsUnnamed,
) {
    tokens_helper(_visitor, &_i.paren_token.span);
    for el in Punctuated::pairs(&_i.unnamed) {
        let it = el.value();
        _visitor.visit_field(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_file<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast File) {
    skip!(_i.shebang);
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    for it in &_i.items {
        _visitor.visit_item(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_fn_arg<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast FnArg) {
    match *_i {
        FnArg::SelfRef(ref _binding_0) => {
            _visitor.visit_arg_self_ref(_binding_0);
        }
        FnArg::SelfValue(ref _binding_0) => {
            _visitor.visit_arg_self(_binding_0);
        }
        FnArg::Captured(ref _binding_0) => {
            _visitor.visit_arg_captured(_binding_0);
        }
        FnArg::Inferred(ref _binding_0) => {
            _visitor.visit_pat(_binding_0);
        }
        FnArg::Ignored(ref _binding_0) => {
            _visitor.visit_type(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_fn_decl<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast FnDecl) {
    tokens_helper(_visitor, &_i.fn_token.span);
    _visitor.visit_generics(&_i.generics);
    tokens_helper(_visitor, &_i.paren_token.span);
    for el in Punctuated::pairs(&_i.inputs) {
        let it = el.value();
        _visitor.visit_fn_arg(it)
    }
    if let Some(ref it) = _i.variadic {
        tokens_helper(_visitor, &it.spans)
    };
    _visitor.visit_return_type(&_i.output);
}
#[cfg(feature = "full")]
pub fn visit_foreign_item<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ForeignItem) {
    match *_i {
        ForeignItem::Fn(ref _binding_0) => {
            _visitor.visit_foreign_item_fn(_binding_0);
        }
        ForeignItem::Static(ref _binding_0) => {
            _visitor.visit_foreign_item_static(_binding_0);
        }
        ForeignItem::Type(ref _binding_0) => {
            _visitor.visit_foreign_item_type(_binding_0);
        }
        ForeignItem::Macro(ref _binding_0) => {
            _visitor.visit_foreign_item_macro(_binding_0);
        }
        ForeignItem::Verbatim(ref _binding_0) => {
            _visitor.visit_foreign_item_verbatim(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_fn<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ForeignItemFn,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_fn_decl(&*_i.decl);
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_macro<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ForeignItemMacro,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_macro(&_i.mac);
    if let Some(ref it) = _i.semi_token {
        tokens_helper(_visitor, &it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_static<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ForeignItemStatic,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.static_token.span);
    if let Some(ref it) = _i.mutability {
        tokens_helper(_visitor, &it.span)
    };
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.colon_token.spans);
    _visitor.visit_type(&*_i.ty);
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_type<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ForeignItemType,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.type_token.span);
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_verbatim<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ForeignItemVerbatim,
) {
    skip!(_i.tts);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_generic_argument<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast GenericArgument,
) {
    match *_i {
        GenericArgument::Lifetime(ref _binding_0) => {
            _visitor.visit_lifetime(_binding_0);
        }
        GenericArgument::Type(ref _binding_0) => {
            _visitor.visit_type(_binding_0);
        }
        GenericArgument::Binding(ref _binding_0) => {
            _visitor.visit_binding(_binding_0);
        }
        GenericArgument::Constraint(ref _binding_0) => {
            _visitor.visit_constraint(_binding_0);
        }
        GenericArgument::Const(ref _binding_0) => {
            _visitor.visit_expr(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_generic_method_argument<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast GenericMethodArgument,
) {
    match *_i {
        GenericMethodArgument::Type(ref _binding_0) => {
            _visitor.visit_type(_binding_0);
        }
        GenericMethodArgument::Const(ref _binding_0) => {
            _visitor.visit_expr(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_generic_param<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast GenericParam,
) {
    match *_i {
        GenericParam::Type(ref _binding_0) => {
            _visitor.visit_type_param(_binding_0);
        }
        GenericParam::Lifetime(ref _binding_0) => {
            _visitor.visit_lifetime_def(_binding_0);
        }
        GenericParam::Const(ref _binding_0) => {
            _visitor.visit_const_param(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_generics<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Generics) {
    if let Some(ref it) = _i.lt_token {
        tokens_helper(_visitor, &it.spans)
    };
    for el in Punctuated::pairs(&_i.params) {
        let it = el.value();
        _visitor.visit_generic_param(it)
    }
    if let Some(ref it) = _i.gt_token {
        tokens_helper(_visitor, &it.spans)
    };
    if let Some(ref it) = _i.where_clause {
        _visitor.visit_where_clause(it)
    };
}
#[cfg(feature = "full")]
pub fn visit_impl_item<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ImplItem) {
    match *_i {
        ImplItem::Const(ref _binding_0) => {
            _visitor.visit_impl_item_const(_binding_0);
        }
        ImplItem::Method(ref _binding_0) => {
            _visitor.visit_impl_item_method(_binding_0);
        }
        ImplItem::Type(ref _binding_0) => {
            _visitor.visit_impl_item_type(_binding_0);
        }
        ImplItem::Existential(ref _binding_0) => {
            _visitor.visit_impl_item_existential(_binding_0);
        }
        ImplItem::Macro(ref _binding_0) => {
            _visitor.visit_impl_item_macro(_binding_0);
        }
        ImplItem::Verbatim(ref _binding_0) => {
            _visitor.visit_impl_item_verbatim(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_impl_item_const<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ImplItemConst,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    if let Some(ref it) = _i.defaultness {
        tokens_helper(_visitor, &it.span)
    };
    tokens_helper(_visitor, &_i.const_token.span);
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.colon_token.spans);
    _visitor.visit_type(&_i.ty);
    tokens_helper(_visitor, &_i.eq_token.spans);
    _visitor.visit_expr(&_i.expr);
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_impl_item_existential<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ImplItemExistential,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.existential_token.span);
    tokens_helper(_visitor, &_i.type_token.span);
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_generics(&_i.generics);
    if let Some(ref it) = _i.colon_token {
        tokens_helper(_visitor, &it.spans)
    };
    for el in Punctuated::pairs(&_i.bounds) {
        let it = el.value();
        _visitor.visit_type_param_bound(it)
    }
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_impl_item_macro<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ImplItemMacro,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_macro(&_i.mac);
    if let Some(ref it) = _i.semi_token {
        tokens_helper(_visitor, &it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_impl_item_method<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ImplItemMethod,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    if let Some(ref it) = _i.defaultness {
        tokens_helper(_visitor, &it.span)
    };
    _visitor.visit_method_sig(&_i.sig);
    _visitor.visit_block(&_i.block);
}
#[cfg(feature = "full")]
pub fn visit_impl_item_type<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ImplItemType,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    if let Some(ref it) = _i.defaultness {
        tokens_helper(_visitor, &it.span)
    };
    tokens_helper(_visitor, &_i.type_token.span);
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_generics(&_i.generics);
    tokens_helper(_visitor, &_i.eq_token.spans);
    _visitor.visit_type(&_i.ty);
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_impl_item_verbatim<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ImplItemVerbatim,
) {
    skip!(_i.tts);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_index<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Index) {
    skip!(_i.index);
    _visitor.visit_span(&_i.span);
}
#[cfg(feature = "full")]
pub fn visit_item<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Item) {
    match *_i {
        Item::ExternCrate(ref _binding_0) => {
            _visitor.visit_item_extern_crate(_binding_0);
        }
        Item::Use(ref _binding_0) => {
            _visitor.visit_item_use(_binding_0);
        }
        Item::Static(ref _binding_0) => {
            _visitor.visit_item_static(_binding_0);
        }
        Item::Const(ref _binding_0) => {
            _visitor.visit_item_const(_binding_0);
        }
        Item::Fn(ref _binding_0) => {
            _visitor.visit_item_fn(_binding_0);
        }
        Item::Mod(ref _binding_0) => {
            _visitor.visit_item_mod(_binding_0);
        }
        Item::ForeignMod(ref _binding_0) => {
            _visitor.visit_item_foreign_mod(_binding_0);
        }
        Item::Type(ref _binding_0) => {
            _visitor.visit_item_type(_binding_0);
        }
        Item::Existential(ref _binding_0) => {
            _visitor.visit_item_existential(_binding_0);
        }
        Item::Struct(ref _binding_0) => {
            _visitor.visit_item_struct(_binding_0);
        }
        Item::Enum(ref _binding_0) => {
            _visitor.visit_item_enum(_binding_0);
        }
        Item::Union(ref _binding_0) => {
            _visitor.visit_item_union(_binding_0);
        }
        Item::Trait(ref _binding_0) => {
            _visitor.visit_item_trait(_binding_0);
        }
        Item::TraitAlias(ref _binding_0) => {
            _visitor.visit_item_trait_alias(_binding_0);
        }
        Item::Impl(ref _binding_0) => {
            _visitor.visit_item_impl(_binding_0);
        }
        Item::Macro(ref _binding_0) => {
            _visitor.visit_item_macro(_binding_0);
        }
        Item::Macro2(ref _binding_0) => {
            _visitor.visit_item_macro2(_binding_0);
        }
        Item::Verbatim(ref _binding_0) => {
            _visitor.visit_item_verbatim(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_item_const<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemConst) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.const_token.span);
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.colon_token.spans);
    _visitor.visit_type(&*_i.ty);
    tokens_helper(_visitor, &_i.eq_token.spans);
    _visitor.visit_expr(&*_i.expr);
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_enum<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemEnum) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.enum_token.span);
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_generics(&_i.generics);
    tokens_helper(_visitor, &_i.brace_token.span);
    for el in Punctuated::pairs(&_i.variants) {
        let it = el.value();
        _visitor.visit_variant(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_item_existential<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ItemExistential,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.existential_token.span);
    tokens_helper(_visitor, &_i.type_token.span);
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_generics(&_i.generics);
    if let Some(ref it) = _i.colon_token {
        tokens_helper(_visitor, &it.spans)
    };
    for el in Punctuated::pairs(&_i.bounds) {
        let it = el.value();
        _visitor.visit_type_param_bound(it)
    }
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_extern_crate<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ItemExternCrate,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.extern_token.span);
    tokens_helper(_visitor, &_i.crate_token.span);
    _visitor.visit_ident(&_i.ident);
    if let Some(ref it) = _i.rename {
        tokens_helper(_visitor, &(it).0.span);
        _visitor.visit_ident(&(it).1);
    };
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_fn<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemFn) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    if let Some(ref it) = _i.constness {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.unsafety {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.asyncness {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.abi {
        _visitor.visit_abi(it)
    };
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_fn_decl(&*_i.decl);
    _visitor.visit_block(&*_i.block);
}
#[cfg(feature = "full")]
pub fn visit_item_foreign_mod<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ItemForeignMod,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_abi(&_i.abi);
    tokens_helper(_visitor, &_i.brace_token.span);
    for it in &_i.items {
        _visitor.visit_foreign_item(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_item_impl<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemImpl) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    if let Some(ref it) = _i.defaultness {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.unsafety {
        tokens_helper(_visitor, &it.span)
    };
    tokens_helper(_visitor, &_i.impl_token.span);
    _visitor.visit_generics(&_i.generics);
    if let Some(ref it) = _i.trait_ {
        if let Some(ref it) = (it).0 {
            tokens_helper(_visitor, &it.spans)
        };
        _visitor.visit_path(&(it).1);
        tokens_helper(_visitor, &(it).2.span);
    };
    _visitor.visit_type(&*_i.self_ty);
    tokens_helper(_visitor, &_i.brace_token.span);
    for it in &_i.items {
        _visitor.visit_impl_item(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_item_macro<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemMacro) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    if let Some(ref it) = _i.ident {
        _visitor.visit_ident(it)
    };
    _visitor.visit_macro(&_i.mac);
    if let Some(ref it) = _i.semi_token {
        tokens_helper(_visitor, &it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_item_macro2<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemMacro2) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.macro_token.span);
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.paren_token.span);
    skip!(_i.args);
    tokens_helper(_visitor, &_i.brace_token.span);
    skip!(_i.body);
}
#[cfg(feature = "full")]
pub fn visit_item_mod<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemMod) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.mod_token.span);
    _visitor.visit_ident(&_i.ident);
    if let Some(ref it) = _i.content {
        tokens_helper(_visitor, &(it).0.span);
        for it in &(it).1 {
            _visitor.visit_item(it)
        }
    };
    if let Some(ref it) = _i.semi {
        tokens_helper(_visitor, &it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_item_static<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemStatic) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.static_token.span);
    if let Some(ref it) = _i.mutability {
        tokens_helper(_visitor, &it.span)
    };
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.colon_token.spans);
    _visitor.visit_type(&*_i.ty);
    tokens_helper(_visitor, &_i.eq_token.spans);
    _visitor.visit_expr(&*_i.expr);
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_struct<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemStruct) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.struct_token.span);
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_generics(&_i.generics);
    _visitor.visit_fields(&_i.fields);
    if let Some(ref it) = _i.semi_token {
        tokens_helper(_visitor, &it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_item_trait<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemTrait) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    if let Some(ref it) = _i.unsafety {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.auto_token {
        tokens_helper(_visitor, &it.span)
    };
    tokens_helper(_visitor, &_i.trait_token.span);
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_generics(&_i.generics);
    if let Some(ref it) = _i.colon_token {
        tokens_helper(_visitor, &it.spans)
    };
    for el in Punctuated::pairs(&_i.supertraits) {
        let it = el.value();
        _visitor.visit_type_param_bound(it)
    }
    tokens_helper(_visitor, &_i.brace_token.span);
    for it in &_i.items {
        _visitor.visit_trait_item(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_item_trait_alias<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ItemTraitAlias,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.trait_token.span);
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_generics(&_i.generics);
    tokens_helper(_visitor, &_i.eq_token.spans);
    for el in Punctuated::pairs(&_i.bounds) {
        let it = el.value();
        _visitor.visit_type_param_bound(it)
    }
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_type<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemType) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.type_token.span);
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_generics(&_i.generics);
    tokens_helper(_visitor, &_i.eq_token.spans);
    _visitor.visit_type(&*_i.ty);
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_union<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemUnion) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.union_token.span);
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_generics(&_i.generics);
    _visitor.visit_fields_named(&_i.fields);
}
#[cfg(feature = "full")]
pub fn visit_item_use<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemUse) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_visibility(&_i.vis);
    tokens_helper(_visitor, &_i.use_token.span);
    if let Some(ref it) = _i.leading_colon {
        tokens_helper(_visitor, &it.spans)
    };
    _visitor.visit_use_tree(&_i.tree);
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_verbatim<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ItemVerbatim,
) {
    skip!(_i.tts);
}
#[cfg(feature = "full")]
pub fn visit_label<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Label) {
    _visitor.visit_lifetime(&_i.name);
    tokens_helper(_visitor, &_i.colon_token.spans);
}
pub fn visit_lifetime<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Lifetime) {
    _visitor.visit_span(&_i.apostrophe);
    _visitor.visit_ident(&_i.ident);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lifetime_def<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast LifetimeDef) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_lifetime(&_i.lifetime);
    if let Some(ref it) = _i.colon_token {
        tokens_helper(_visitor, &it.spans)
    };
    for el in Punctuated::pairs(&_i.bounds) {
        let it = el.value();
        _visitor.visit_lifetime(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Lit) {
    match *_i {
        Lit::Str(ref _binding_0) => {
            _visitor.visit_lit_str(_binding_0);
        }
        Lit::ByteStr(ref _binding_0) => {
            _visitor.visit_lit_byte_str(_binding_0);
        }
        Lit::Byte(ref _binding_0) => {
            _visitor.visit_lit_byte(_binding_0);
        }
        Lit::Char(ref _binding_0) => {
            _visitor.visit_lit_char(_binding_0);
        }
        Lit::Int(ref _binding_0) => {
            _visitor.visit_lit_int(_binding_0);
        }
        Lit::Float(ref _binding_0) => {
            _visitor.visit_lit_float(_binding_0);
        }
        Lit::Bool(ref _binding_0) => {
            _visitor.visit_lit_bool(_binding_0);
        }
        Lit::Verbatim(ref _binding_0) => {
            _visitor.visit_lit_verbatim(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_bool<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast LitBool) {
    skip!(_i.value);
    _visitor.visit_span(&_i.span);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_byte<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast LitByte) {}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_byte_str<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast LitByteStr) {}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_char<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast LitChar) {}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_float<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast LitFloat) {}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_int<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast LitInt) {}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_str<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast LitStr) {}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_verbatim<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast LitVerbatim) {
    skip!(_i.token);
}
#[cfg(feature = "full")]
pub fn visit_local<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Local) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.let_token.span);
    for el in Punctuated::pairs(&_i.pats) {
        let it = el.value();
        _visitor.visit_pat(it)
    }
    if let Some(ref it) = _i.ty {
        tokens_helper(_visitor, &(it).0.spans);
        _visitor.visit_type(&*(it).1);
    };
    if let Some(ref it) = _i.init {
        tokens_helper(_visitor, &(it).0.spans);
        _visitor.visit_expr(&*(it).1);
    };
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_macro<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Macro) {
    _visitor.visit_path(&_i.path);
    tokens_helper(_visitor, &_i.bang_token.spans);
    _visitor.visit_macro_delimiter(&_i.delimiter);
    skip!(_i.tts);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_macro_delimiter<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast MacroDelimiter,
) {
    match *_i {
        MacroDelimiter::Paren(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.span);
        }
        MacroDelimiter::Brace(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.span);
        }
        MacroDelimiter::Bracket(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.span);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_member<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Member) {
    match *_i {
        Member::Named(ref _binding_0) => {
            _visitor.visit_ident(_binding_0);
        }
        Member::Unnamed(ref _binding_0) => {
            _visitor.visit_index(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_meta<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Meta) {
    match *_i {
        Meta::Word(ref _binding_0) => {
            _visitor.visit_ident(_binding_0);
        }
        Meta::List(ref _binding_0) => {
            _visitor.visit_meta_list(_binding_0);
        }
        Meta::NameValue(ref _binding_0) => {
            _visitor.visit_meta_name_value(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_meta_list<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast MetaList) {
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.paren_token.span);
    for el in Punctuated::pairs(&_i.nested) {
        let it = el.value();
        _visitor.visit_nested_meta(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_meta_name_value<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast MetaNameValue,
) {
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.eq_token.spans);
    _visitor.visit_lit(&_i.lit);
}
#[cfg(feature = "full")]
pub fn visit_method_sig<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast MethodSig) {
    if let Some(ref it) = _i.constness {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.unsafety {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.asyncness {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.abi {
        _visitor.visit_abi(it)
    };
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_fn_decl(&_i.decl);
}
#[cfg(feature = "full")]
pub fn visit_method_turbofish<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast MethodTurbofish,
) {
    tokens_helper(_visitor, &_i.colon2_token.spans);
    tokens_helper(_visitor, &_i.lt_token.spans);
    for el in Punctuated::pairs(&_i.args) {
        let it = el.value();
        _visitor.visit_generic_method_argument(it)
    }
    tokens_helper(_visitor, &_i.gt_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_nested_meta<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast NestedMeta) {
    match *_i {
        NestedMeta::Meta(ref _binding_0) => {
            _visitor.visit_meta(_binding_0);
        }
        NestedMeta::Literal(ref _binding_0) => {
            _visitor.visit_lit(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_parenthesized_generic_arguments<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast ParenthesizedGenericArguments,
) {
    tokens_helper(_visitor, &_i.paren_token.span);
    for el in Punctuated::pairs(&_i.inputs) {
        let it = el.value();
        _visitor.visit_type(it)
    }
    _visitor.visit_return_type(&_i.output);
}
#[cfg(feature = "full")]
pub fn visit_pat<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Pat) {
    match *_i {
        Pat::Wild(ref _binding_0) => {
            _visitor.visit_pat_wild(_binding_0);
        }
        Pat::Ident(ref _binding_0) => {
            _visitor.visit_pat_ident(_binding_0);
        }
        Pat::Struct(ref _binding_0) => {
            _visitor.visit_pat_struct(_binding_0);
        }
        Pat::TupleStruct(ref _binding_0) => {
            _visitor.visit_pat_tuple_struct(_binding_0);
        }
        Pat::Path(ref _binding_0) => {
            _visitor.visit_pat_path(_binding_0);
        }
        Pat::Tuple(ref _binding_0) => {
            _visitor.visit_pat_tuple(_binding_0);
        }
        Pat::Box(ref _binding_0) => {
            _visitor.visit_pat_box(_binding_0);
        }
        Pat::Ref(ref _binding_0) => {
            _visitor.visit_pat_ref(_binding_0);
        }
        Pat::Lit(ref _binding_0) => {
            _visitor.visit_pat_lit(_binding_0);
        }
        Pat::Range(ref _binding_0) => {
            _visitor.visit_pat_range(_binding_0);
        }
        Pat::Slice(ref _binding_0) => {
            _visitor.visit_pat_slice(_binding_0);
        }
        Pat::Macro(ref _binding_0) => {
            _visitor.visit_pat_macro(_binding_0);
        }
        Pat::Verbatim(ref _binding_0) => {
            _visitor.visit_pat_verbatim(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_pat_box<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatBox) {
    tokens_helper(_visitor, &_i.box_token.span);
    _visitor.visit_pat(&*_i.pat);
}
#[cfg(feature = "full")]
pub fn visit_pat_ident<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatIdent) {
    if let Some(ref it) = _i.by_ref {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.mutability {
        tokens_helper(_visitor, &it.span)
    };
    _visitor.visit_ident(&_i.ident);
    if let Some(ref it) = _i.subpat {
        tokens_helper(_visitor, &(it).0.spans);
        _visitor.visit_pat(&*(it).1);
    };
}
#[cfg(feature = "full")]
pub fn visit_pat_lit<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatLit) {
    _visitor.visit_expr(&*_i.expr);
}
#[cfg(feature = "full")]
pub fn visit_pat_macro<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatMacro) {
    _visitor.visit_macro(&_i.mac);
}
#[cfg(feature = "full")]
pub fn visit_pat_path<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatPath) {
    if let Some(ref it) = _i.qself {
        _visitor.visit_qself(it)
    };
    _visitor.visit_path(&_i.path);
}
#[cfg(feature = "full")]
pub fn visit_pat_range<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatRange) {
    _visitor.visit_expr(&*_i.lo);
    _visitor.visit_range_limits(&_i.limits);
    _visitor.visit_expr(&*_i.hi);
}
#[cfg(feature = "full")]
pub fn visit_pat_ref<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatRef) {
    tokens_helper(_visitor, &_i.and_token.spans);
    if let Some(ref it) = _i.mutability {
        tokens_helper(_visitor, &it.span)
    };
    _visitor.visit_pat(&*_i.pat);
}
#[cfg(feature = "full")]
pub fn visit_pat_slice<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatSlice) {
    tokens_helper(_visitor, &_i.bracket_token.span);
    for el in Punctuated::pairs(&_i.front) {
        let it = el.value();
        _visitor.visit_pat(it)
    }
    if let Some(ref it) = _i.middle {
        _visitor.visit_pat(&**it)
    };
    if let Some(ref it) = _i.dot2_token {
        tokens_helper(_visitor, &it.spans)
    };
    if let Some(ref it) = _i.comma_token {
        tokens_helper(_visitor, &it.spans)
    };
    for el in Punctuated::pairs(&_i.back) {
        let it = el.value();
        _visitor.visit_pat(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_pat_struct<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatStruct) {
    _visitor.visit_path(&_i.path);
    tokens_helper(_visitor, &_i.brace_token.span);
    for el in Punctuated::pairs(&_i.fields) {
        let it = el.value();
        _visitor.visit_field_pat(it)
    }
    if let Some(ref it) = _i.dot2_token {
        tokens_helper(_visitor, &it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_pat_tuple<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatTuple) {
    tokens_helper(_visitor, &_i.paren_token.span);
    for el in Punctuated::pairs(&_i.front) {
        let it = el.value();
        _visitor.visit_pat(it)
    }
    if let Some(ref it) = _i.dot2_token {
        tokens_helper(_visitor, &it.spans)
    };
    if let Some(ref it) = _i.comma_token {
        tokens_helper(_visitor, &it.spans)
    };
    for el in Punctuated::pairs(&_i.back) {
        let it = el.value();
        _visitor.visit_pat(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_pat_tuple_struct<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast PatTupleStruct,
) {
    _visitor.visit_path(&_i.path);
    _visitor.visit_pat_tuple(&_i.pat);
}
#[cfg(feature = "full")]
pub fn visit_pat_verbatim<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatVerbatim) {
    skip!(_i.tts);
}
#[cfg(feature = "full")]
pub fn visit_pat_wild<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatWild) {
    tokens_helper(_visitor, &_i.underscore_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_path<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Path) {
    if let Some(ref it) = _i.leading_colon {
        tokens_helper(_visitor, &it.spans)
    };
    for el in Punctuated::pairs(&_i.segments) {
        let it = el.value();
        _visitor.visit_path_segment(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_path_arguments<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast PathArguments,
) {
    match *_i {
        PathArguments::None => {}
        PathArguments::AngleBracketed(ref _binding_0) => {
            _visitor.visit_angle_bracketed_generic_arguments(_binding_0);
        }
        PathArguments::Parenthesized(ref _binding_0) => {
            _visitor.visit_parenthesized_generic_arguments(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_path_segment<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PathSegment) {
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_path_arguments(&_i.arguments);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_predicate_eq<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PredicateEq) {
    _visitor.visit_type(&_i.lhs_ty);
    tokens_helper(_visitor, &_i.eq_token.spans);
    _visitor.visit_type(&_i.rhs_ty);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_predicate_lifetime<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast PredicateLifetime,
) {
    _visitor.visit_lifetime(&_i.lifetime);
    tokens_helper(_visitor, &_i.colon_token.spans);
    for el in Punctuated::pairs(&_i.bounds) {
        let it = el.value();
        _visitor.visit_lifetime(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_predicate_type<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast PredicateType,
) {
    if let Some(ref it) = _i.lifetimes {
        _visitor.visit_bound_lifetimes(it)
    };
    _visitor.visit_type(&_i.bounded_ty);
    tokens_helper(_visitor, &_i.colon_token.spans);
    for el in Punctuated::pairs(&_i.bounds) {
        let it = el.value();
        _visitor.visit_type_param_bound(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_qself<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast QSelf) {
    tokens_helper(_visitor, &_i.lt_token.spans);
    _visitor.visit_type(&*_i.ty);
    skip!(_i.position);
    if let Some(ref it) = _i.as_token {
        tokens_helper(_visitor, &it.span)
    };
    tokens_helper(_visitor, &_i.gt_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_range_limits<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast RangeLimits) {
    match *_i {
        RangeLimits::HalfOpen(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        RangeLimits::Closed(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_return_type<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ReturnType) {
    match *_i {
        ReturnType::Default => {}
        ReturnType::Type(ref _binding_0, ref _binding_1) => {
            tokens_helper(_visitor, &_binding_0.spans);
            _visitor.visit_type(&**_binding_1);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_stmt<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Stmt) {
    match *_i {
        Stmt::Local(ref _binding_0) => {
            _visitor.visit_local(_binding_0);
        }
        Stmt::Item(ref _binding_0) => {
            _visitor.visit_item(_binding_0);
        }
        Stmt::Expr(ref _binding_0) => {
            _visitor.visit_expr(_binding_0);
        }
        Stmt::Semi(ref _binding_0, ref _binding_1) => {
            _visitor.visit_expr(_binding_0);
            tokens_helper(_visitor, &_binding_1.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_trait_bound<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TraitBound) {
    if let Some(ref it) = _i.paren_token {
        tokens_helper(_visitor, &it.span)
    };
    _visitor.visit_trait_bound_modifier(&_i.modifier);
    if let Some(ref it) = _i.lifetimes {
        _visitor.visit_bound_lifetimes(it)
    };
    _visitor.visit_path(&_i.path);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_trait_bound_modifier<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast TraitBoundModifier,
) {
    match *_i {
        TraitBoundModifier::None => {}
        TraitBoundModifier::Maybe(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_trait_item<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TraitItem) {
    match *_i {
        TraitItem::Const(ref _binding_0) => {
            _visitor.visit_trait_item_const(_binding_0);
        }
        TraitItem::Method(ref _binding_0) => {
            _visitor.visit_trait_item_method(_binding_0);
        }
        TraitItem::Type(ref _binding_0) => {
            _visitor.visit_trait_item_type(_binding_0);
        }
        TraitItem::Macro(ref _binding_0) => {
            _visitor.visit_trait_item_macro(_binding_0);
        }
        TraitItem::Verbatim(ref _binding_0) => {
            _visitor.visit_trait_item_verbatim(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_trait_item_const<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast TraitItemConst,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.const_token.span);
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.colon_token.spans);
    _visitor.visit_type(&_i.ty);
    if let Some(ref it) = _i.default {
        tokens_helper(_visitor, &(it).0.spans);
        _visitor.visit_expr(&(it).1);
    };
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_trait_item_macro<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast TraitItemMacro,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_macro(&_i.mac);
    if let Some(ref it) = _i.semi_token {
        tokens_helper(_visitor, &it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_trait_item_method<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast TraitItemMethod,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_method_sig(&_i.sig);
    if let Some(ref it) = _i.default {
        _visitor.visit_block(it)
    };
    if let Some(ref it) = _i.semi_token {
        tokens_helper(_visitor, &it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_trait_item_type<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast TraitItemType,
) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    tokens_helper(_visitor, &_i.type_token.span);
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_generics(&_i.generics);
    if let Some(ref it) = _i.colon_token {
        tokens_helper(_visitor, &it.spans)
    };
    for el in Punctuated::pairs(&_i.bounds) {
        let it = el.value();
        _visitor.visit_type_param_bound(it)
    }
    if let Some(ref it) = _i.default {
        tokens_helper(_visitor, &(it).0.spans);
        _visitor.visit_type(&(it).1);
    };
    tokens_helper(_visitor, &_i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_trait_item_verbatim<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast TraitItemVerbatim,
) {
    skip!(_i.tts);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Type) {
    match *_i {
        Type::Slice(ref _binding_0) => {
            _visitor.visit_type_slice(_binding_0);
        }
        Type::Array(ref _binding_0) => {
            _visitor.visit_type_array(_binding_0);
        }
        Type::Ptr(ref _binding_0) => {
            _visitor.visit_type_ptr(_binding_0);
        }
        Type::Reference(ref _binding_0) => {
            _visitor.visit_type_reference(_binding_0);
        }
        Type::BareFn(ref _binding_0) => {
            _visitor.visit_type_bare_fn(_binding_0);
        }
        Type::Never(ref _binding_0) => {
            _visitor.visit_type_never(_binding_0);
        }
        Type::Tuple(ref _binding_0) => {
            _visitor.visit_type_tuple(_binding_0);
        }
        Type::Path(ref _binding_0) => {
            _visitor.visit_type_path(_binding_0);
        }
        Type::TraitObject(ref _binding_0) => {
            _visitor.visit_type_trait_object(_binding_0);
        }
        Type::ImplTrait(ref _binding_0) => {
            _visitor.visit_type_impl_trait(_binding_0);
        }
        Type::Paren(ref _binding_0) => {
            _visitor.visit_type_paren(_binding_0);
        }
        Type::Group(ref _binding_0) => {
            _visitor.visit_type_group(_binding_0);
        }
        Type::Infer(ref _binding_0) => {
            _visitor.visit_type_infer(_binding_0);
        }
        Type::Macro(ref _binding_0) => {
            _visitor.visit_type_macro(_binding_0);
        }
        Type::Verbatim(ref _binding_0) => {
            _visitor.visit_type_verbatim(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_array<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeArray) {
    tokens_helper(_visitor, &_i.bracket_token.span);
    _visitor.visit_type(&*_i.elem);
    tokens_helper(_visitor, &_i.semi_token.spans);
    _visitor.visit_expr(&_i.len);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_bare_fn<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeBareFn) {
    if let Some(ref it) = _i.lifetimes {
        _visitor.visit_bound_lifetimes(it)
    };
    if let Some(ref it) = _i.unsafety {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.abi {
        _visitor.visit_abi(it)
    };
    tokens_helper(_visitor, &_i.fn_token.span);
    tokens_helper(_visitor, &_i.paren_token.span);
    for el in Punctuated::pairs(&_i.inputs) {
        let it = el.value();
        _visitor.visit_bare_fn_arg(it)
    }
    if let Some(ref it) = _i.variadic {
        tokens_helper(_visitor, &it.spans)
    };
    _visitor.visit_return_type(&_i.output);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_group<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeGroup) {
    tokens_helper(_visitor, &_i.group_token.span);
    _visitor.visit_type(&*_i.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_impl_trait<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast TypeImplTrait,
) {
    tokens_helper(_visitor, &_i.impl_token.span);
    for el in Punctuated::pairs(&_i.bounds) {
        let it = el.value();
        _visitor.visit_type_param_bound(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_infer<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeInfer) {
    tokens_helper(_visitor, &_i.underscore_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_macro<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeMacro) {
    _visitor.visit_macro(&_i.mac);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_never<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeNever) {
    tokens_helper(_visitor, &_i.bang_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_param<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeParam) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_ident(&_i.ident);
    if let Some(ref it) = _i.colon_token {
        tokens_helper(_visitor, &it.spans)
    };
    for el in Punctuated::pairs(&_i.bounds) {
        let it = el.value();
        _visitor.visit_type_param_bound(it)
    }
    if let Some(ref it) = _i.eq_token {
        tokens_helper(_visitor, &it.spans)
    };
    if let Some(ref it) = _i.default {
        _visitor.visit_type(it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_param_bound<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast TypeParamBound,
) {
    match *_i {
        TypeParamBound::Trait(ref _binding_0) => {
            _visitor.visit_trait_bound(_binding_0);
        }
        TypeParamBound::Lifetime(ref _binding_0) => {
            _visitor.visit_lifetime(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_paren<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeParen) {
    tokens_helper(_visitor, &_i.paren_token.span);
    _visitor.visit_type(&*_i.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_path<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypePath) {
    if let Some(ref it) = _i.qself {
        _visitor.visit_qself(it)
    };
    _visitor.visit_path(&_i.path);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_ptr<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypePtr) {
    tokens_helper(_visitor, &_i.star_token.spans);
    if let Some(ref it) = _i.const_token {
        tokens_helper(_visitor, &it.span)
    };
    if let Some(ref it) = _i.mutability {
        tokens_helper(_visitor, &it.span)
    };
    _visitor.visit_type(&*_i.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_reference<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast TypeReference,
) {
    tokens_helper(_visitor, &_i.and_token.spans);
    if let Some(ref it) = _i.lifetime {
        _visitor.visit_lifetime(it)
    };
    if let Some(ref it) = _i.mutability {
        tokens_helper(_visitor, &it.span)
    };
    _visitor.visit_type(&*_i.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_slice<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeSlice) {
    tokens_helper(_visitor, &_i.bracket_token.span);
    _visitor.visit_type(&*_i.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_trait_object<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast TypeTraitObject,
) {
    if let Some(ref it) = _i.dyn_token {
        tokens_helper(_visitor, &it.span)
    };
    for el in Punctuated::pairs(&_i.bounds) {
        let it = el.value();
        _visitor.visit_type_param_bound(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_tuple<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeTuple) {
    tokens_helper(_visitor, &_i.paren_token.span);
    for el in Punctuated::pairs(&_i.elems) {
        let it = el.value();
        _visitor.visit_type(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_verbatim<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast TypeVerbatim,
) {
    skip!(_i.tts);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_un_op<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast UnOp) {
    match *_i {
        UnOp::Deref(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        UnOp::Not(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
        UnOp::Neg(ref _binding_0) => {
            tokens_helper(_visitor, &_binding_0.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_use_glob<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast UseGlob) {
    tokens_helper(_visitor, &_i.star_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_use_group<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast UseGroup) {
    tokens_helper(_visitor, &_i.brace_token.span);
    for el in Punctuated::pairs(&_i.items) {
        let it = el.value();
        _visitor.visit_use_tree(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_use_name<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast UseName) {
    _visitor.visit_ident(&_i.ident);
}
#[cfg(feature = "full")]
pub fn visit_use_path<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast UsePath) {
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.colon2_token.spans);
    _visitor.visit_use_tree(&*_i.tree);
}
#[cfg(feature = "full")]
pub fn visit_use_rename<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast UseRename) {
    _visitor.visit_ident(&_i.ident);
    tokens_helper(_visitor, &_i.as_token.span);
    _visitor.visit_ident(&_i.rename);
}
#[cfg(feature = "full")]
pub fn visit_use_tree<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast UseTree) {
    match *_i {
        UseTree::Path(ref _binding_0) => {
            _visitor.visit_use_path(_binding_0);
        }
        UseTree::Name(ref _binding_0) => {
            _visitor.visit_use_name(_binding_0);
        }
        UseTree::Rename(ref _binding_0) => {
            _visitor.visit_use_rename(_binding_0);
        }
        UseTree::Glob(ref _binding_0) => {
            _visitor.visit_use_glob(_binding_0);
        }
        UseTree::Group(ref _binding_0) => {
            _visitor.visit_use_group(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_variant<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Variant) {
    for it in &_i.attrs {
        _visitor.visit_attribute(it)
    }
    _visitor.visit_ident(&_i.ident);
    _visitor.visit_fields(&_i.fields);
    if let Some(ref it) = _i.discriminant {
        tokens_helper(_visitor, &(it).0.spans);
        _visitor.visit_expr(&(it).1);
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_vis_crate<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast VisCrate) {
    tokens_helper(_visitor, &_i.crate_token.span);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_vis_public<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast VisPublic) {
    tokens_helper(_visitor, &_i.pub_token.span);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_vis_restricted<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast VisRestricted,
) {
    tokens_helper(_visitor, &_i.pub_token.span);
    tokens_helper(_visitor, &_i.paren_token.span);
    if let Some(ref it) = _i.in_token {
        tokens_helper(_visitor, &it.span)
    };
    _visitor.visit_path(&*_i.path);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_visibility<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Visibility) {
    match *_i {
        Visibility::Public(ref _binding_0) => {
            _visitor.visit_vis_public(_binding_0);
        }
        Visibility::Crate(ref _binding_0) => {
            _visitor.visit_vis_crate(_binding_0);
        }
        Visibility::Restricted(ref _binding_0) => {
            _visitor.visit_vis_restricted(_binding_0);
        }
        Visibility::Inherited => {}
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_where_clause<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast WhereClause) {
    tokens_helper(_visitor, &_i.where_token.span);
    for el in Punctuated::pairs(&_i.predicates) {
        let it = el.value();
        _visitor.visit_where_predicate(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_where_predicate<'ast, V: Visit<'ast> + ?Sized>(
    _visitor: &mut V,
    _i: &'ast WherePredicate,
) {
    match *_i {
        WherePredicate::Type(ref _binding_0) => {
            _visitor.visit_predicate_type(_binding_0);
        }
        WherePredicate::Lifetime(ref _binding_0) => {
            _visitor.visit_predicate_lifetime(_binding_0);
        }
        WherePredicate::Eq(ref _binding_0) => {
            _visitor.visit_predicate_eq(_binding_0);
        }
    }
}
pub fn visit_span<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Span) {}
pub fn visit_ident<'ast, V: Visit<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Ident) {}
