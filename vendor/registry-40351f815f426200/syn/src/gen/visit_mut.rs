// THIS FILE IS AUTOMATICALLY GENERATED; DO NOT EDIT

#[cfg(any(feature = "full", feature = "derive"))]
use gen::helper::visit_mut::*;
use proc_macro2::Span;
#[cfg(any(feature = "full", feature = "derive"))]
use punctuated::Punctuated;
use *;
#[cfg(feature = "full")]
macro_rules! full {
    ($e:expr) => {
        $e
    };
}
#[cfg(all(feature = "derive", not(feature = "full")))]
macro_rules! full {
    ($e:expr) => {
        unreachable!()
    };
}
#[cfg(any(feature = "full", feature = "derive"))]
macro_rules! skip {
    ($($tt:tt)*) => {};
}
/// Syntax tree traversal to mutate an exclusive borrow of a syntax tree in
/// place.
///
/// See the [module documentation] for details.
///
/// [module documentation]: index.html
///
/// *This trait is available if Syn is built with the `"visit-mut"` feature.*
pub trait VisitMut {
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_abi_mut(&mut self, i: &mut Abi) {
        visit_abi_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_angle_bracketed_generic_arguments_mut(
        &mut self,
        i: &mut AngleBracketedGenericArguments,
    ) {
        visit_angle_bracketed_generic_arguments_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_arg_captured_mut(&mut self, i: &mut ArgCaptured) {
        visit_arg_captured_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_arg_self_mut(&mut self, i: &mut ArgSelf) {
        visit_arg_self_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_arg_self_ref_mut(&mut self, i: &mut ArgSelfRef) {
        visit_arg_self_ref_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_arm_mut(&mut self, i: &mut Arm) {
        visit_arm_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_attr_style_mut(&mut self, i: &mut AttrStyle) {
        visit_attr_style_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_attribute_mut(&mut self, i: &mut Attribute) {
        visit_attribute_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_bare_fn_arg_mut(&mut self, i: &mut BareFnArg) {
        visit_bare_fn_arg_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_bare_fn_arg_name_mut(&mut self, i: &mut BareFnArgName) {
        visit_bare_fn_arg_name_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_bin_op_mut(&mut self, i: &mut BinOp) {
        visit_bin_op_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_binding_mut(&mut self, i: &mut Binding) {
        visit_binding_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_block_mut(&mut self, i: &mut Block) {
        visit_block_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_bound_lifetimes_mut(&mut self, i: &mut BoundLifetimes) {
        visit_bound_lifetimes_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_const_param_mut(&mut self, i: &mut ConstParam) {
        visit_const_param_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_constraint_mut(&mut self, i: &mut Constraint) {
        visit_constraint_mut(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_data_mut(&mut self, i: &mut Data) {
        visit_data_mut(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_data_enum_mut(&mut self, i: &mut DataEnum) {
        visit_data_enum_mut(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_data_struct_mut(&mut self, i: &mut DataStruct) {
        visit_data_struct_mut(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_data_union_mut(&mut self, i: &mut DataUnion) {
        visit_data_union_mut(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_derive_input_mut(&mut self, i: &mut DeriveInput) {
        visit_derive_input_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_mut(&mut self, i: &mut Expr) {
        visit_expr_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_array_mut(&mut self, i: &mut ExprArray) {
        visit_expr_array_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_assign_mut(&mut self, i: &mut ExprAssign) {
        visit_expr_assign_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_assign_op_mut(&mut self, i: &mut ExprAssignOp) {
        visit_expr_assign_op_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_async_mut(&mut self, i: &mut ExprAsync) {
        visit_expr_async_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_binary_mut(&mut self, i: &mut ExprBinary) {
        visit_expr_binary_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_block_mut(&mut self, i: &mut ExprBlock) {
        visit_expr_block_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_box_mut(&mut self, i: &mut ExprBox) {
        visit_expr_box_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_break_mut(&mut self, i: &mut ExprBreak) {
        visit_expr_break_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_call_mut(&mut self, i: &mut ExprCall) {
        visit_expr_call_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_cast_mut(&mut self, i: &mut ExprCast) {
        visit_expr_cast_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_closure_mut(&mut self, i: &mut ExprClosure) {
        visit_expr_closure_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_continue_mut(&mut self, i: &mut ExprContinue) {
        visit_expr_continue_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_field_mut(&mut self, i: &mut ExprField) {
        visit_expr_field_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_for_loop_mut(&mut self, i: &mut ExprForLoop) {
        visit_expr_for_loop_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_group_mut(&mut self, i: &mut ExprGroup) {
        visit_expr_group_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_if_mut(&mut self, i: &mut ExprIf) {
        visit_expr_if_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_in_place_mut(&mut self, i: &mut ExprInPlace) {
        visit_expr_in_place_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_index_mut(&mut self, i: &mut ExprIndex) {
        visit_expr_index_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_let_mut(&mut self, i: &mut ExprLet) {
        visit_expr_let_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_lit_mut(&mut self, i: &mut ExprLit) {
        visit_expr_lit_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_loop_mut(&mut self, i: &mut ExprLoop) {
        visit_expr_loop_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_macro_mut(&mut self, i: &mut ExprMacro) {
        visit_expr_macro_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_match_mut(&mut self, i: &mut ExprMatch) {
        visit_expr_match_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_method_call_mut(&mut self, i: &mut ExprMethodCall) {
        visit_expr_method_call_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_paren_mut(&mut self, i: &mut ExprParen) {
        visit_expr_paren_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_path_mut(&mut self, i: &mut ExprPath) {
        visit_expr_path_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_range_mut(&mut self, i: &mut ExprRange) {
        visit_expr_range_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_reference_mut(&mut self, i: &mut ExprReference) {
        visit_expr_reference_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_repeat_mut(&mut self, i: &mut ExprRepeat) {
        visit_expr_repeat_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_return_mut(&mut self, i: &mut ExprReturn) {
        visit_expr_return_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_struct_mut(&mut self, i: &mut ExprStruct) {
        visit_expr_struct_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_try_mut(&mut self, i: &mut ExprTry) {
        visit_expr_try_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_try_block_mut(&mut self, i: &mut ExprTryBlock) {
        visit_expr_try_block_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_tuple_mut(&mut self, i: &mut ExprTuple) {
        visit_expr_tuple_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_type_mut(&mut self, i: &mut ExprType) {
        visit_expr_type_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_unary_mut(&mut self, i: &mut ExprUnary) {
        visit_expr_unary_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_unsafe_mut(&mut self, i: &mut ExprUnsafe) {
        visit_expr_unsafe_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_verbatim_mut(&mut self, i: &mut ExprVerbatim) {
        visit_expr_verbatim_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_while_mut(&mut self, i: &mut ExprWhile) {
        visit_expr_while_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_yield_mut(&mut self, i: &mut ExprYield) {
        visit_expr_yield_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_field_mut(&mut self, i: &mut Field) {
        visit_field_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_field_pat_mut(&mut self, i: &mut FieldPat) {
        visit_field_pat_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_field_value_mut(&mut self, i: &mut FieldValue) {
        visit_field_value_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_fields_mut(&mut self, i: &mut Fields) {
        visit_fields_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_fields_named_mut(&mut self, i: &mut FieldsNamed) {
        visit_fields_named_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_fields_unnamed_mut(&mut self, i: &mut FieldsUnnamed) {
        visit_fields_unnamed_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_file_mut(&mut self, i: &mut File) {
        visit_file_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_fn_arg_mut(&mut self, i: &mut FnArg) {
        visit_fn_arg_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_fn_decl_mut(&mut self, i: &mut FnDecl) {
        visit_fn_decl_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_mut(&mut self, i: &mut ForeignItem) {
        visit_foreign_item_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_fn_mut(&mut self, i: &mut ForeignItemFn) {
        visit_foreign_item_fn_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_macro_mut(&mut self, i: &mut ForeignItemMacro) {
        visit_foreign_item_macro_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_static_mut(&mut self, i: &mut ForeignItemStatic) {
        visit_foreign_item_static_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_type_mut(&mut self, i: &mut ForeignItemType) {
        visit_foreign_item_type_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_verbatim_mut(&mut self, i: &mut ForeignItemVerbatim) {
        visit_foreign_item_verbatim_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_generic_argument_mut(&mut self, i: &mut GenericArgument) {
        visit_generic_argument_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_generic_method_argument_mut(&mut self, i: &mut GenericMethodArgument) {
        visit_generic_method_argument_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_generic_param_mut(&mut self, i: &mut GenericParam) {
        visit_generic_param_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_generics_mut(&mut self, i: &mut Generics) {
        visit_generics_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_mut(&mut self, i: &mut ImplItem) {
        visit_impl_item_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_const_mut(&mut self, i: &mut ImplItemConst) {
        visit_impl_item_const_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_existential_mut(&mut self, i: &mut ImplItemExistential) {
        visit_impl_item_existential_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_macro_mut(&mut self, i: &mut ImplItemMacro) {
        visit_impl_item_macro_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_method_mut(&mut self, i: &mut ImplItemMethod) {
        visit_impl_item_method_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_type_mut(&mut self, i: &mut ImplItemType) {
        visit_impl_item_type_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_verbatim_mut(&mut self, i: &mut ImplItemVerbatim) {
        visit_impl_item_verbatim_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_index_mut(&mut self, i: &mut Index) {
        visit_index_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_mut(&mut self, i: &mut Item) {
        visit_item_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_const_mut(&mut self, i: &mut ItemConst) {
        visit_item_const_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_enum_mut(&mut self, i: &mut ItemEnum) {
        visit_item_enum_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_existential_mut(&mut self, i: &mut ItemExistential) {
        visit_item_existential_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_extern_crate_mut(&mut self, i: &mut ItemExternCrate) {
        visit_item_extern_crate_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_fn_mut(&mut self, i: &mut ItemFn) {
        visit_item_fn_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_foreign_mod_mut(&mut self, i: &mut ItemForeignMod) {
        visit_item_foreign_mod_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_impl_mut(&mut self, i: &mut ItemImpl) {
        visit_item_impl_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_macro_mut(&mut self, i: &mut ItemMacro) {
        visit_item_macro_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_macro2_mut(&mut self, i: &mut ItemMacro2) {
        visit_item_macro2_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_mod_mut(&mut self, i: &mut ItemMod) {
        visit_item_mod_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_static_mut(&mut self, i: &mut ItemStatic) {
        visit_item_static_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_struct_mut(&mut self, i: &mut ItemStruct) {
        visit_item_struct_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_trait_mut(&mut self, i: &mut ItemTrait) {
        visit_item_trait_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_trait_alias_mut(&mut self, i: &mut ItemTraitAlias) {
        visit_item_trait_alias_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_type_mut(&mut self, i: &mut ItemType) {
        visit_item_type_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_union_mut(&mut self, i: &mut ItemUnion) {
        visit_item_union_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_use_mut(&mut self, i: &mut ItemUse) {
        visit_item_use_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_verbatim_mut(&mut self, i: &mut ItemVerbatim) {
        visit_item_verbatim_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_label_mut(&mut self, i: &mut Label) {
        visit_label_mut(self, i)
    }
    fn visit_lifetime_mut(&mut self, i: &mut Lifetime) {
        visit_lifetime_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lifetime_def_mut(&mut self, i: &mut LifetimeDef) {
        visit_lifetime_def_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_mut(&mut self, i: &mut Lit) {
        visit_lit_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_bool_mut(&mut self, i: &mut LitBool) {
        visit_lit_bool_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_byte_mut(&mut self, i: &mut LitByte) {
        visit_lit_byte_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_byte_str_mut(&mut self, i: &mut LitByteStr) {
        visit_lit_byte_str_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_char_mut(&mut self, i: &mut LitChar) {
        visit_lit_char_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_float_mut(&mut self, i: &mut LitFloat) {
        visit_lit_float_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_int_mut(&mut self, i: &mut LitInt) {
        visit_lit_int_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_str_mut(&mut self, i: &mut LitStr) {
        visit_lit_str_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lit_verbatim_mut(&mut self, i: &mut LitVerbatim) {
        visit_lit_verbatim_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_local_mut(&mut self, i: &mut Local) {
        visit_local_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_macro_mut(&mut self, i: &mut Macro) {
        visit_macro_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_macro_delimiter_mut(&mut self, i: &mut MacroDelimiter) {
        visit_macro_delimiter_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_member_mut(&mut self, i: &mut Member) {
        visit_member_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_meta_mut(&mut self, i: &mut Meta) {
        visit_meta_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_meta_list_mut(&mut self, i: &mut MetaList) {
        visit_meta_list_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_meta_name_value_mut(&mut self, i: &mut MetaNameValue) {
        visit_meta_name_value_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_method_sig_mut(&mut self, i: &mut MethodSig) {
        visit_method_sig_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_method_turbofish_mut(&mut self, i: &mut MethodTurbofish) {
        visit_method_turbofish_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_nested_meta_mut(&mut self, i: &mut NestedMeta) {
        visit_nested_meta_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_parenthesized_generic_arguments_mut(&mut self, i: &mut ParenthesizedGenericArguments) {
        visit_parenthesized_generic_arguments_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_mut(&mut self, i: &mut Pat) {
        visit_pat_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_box_mut(&mut self, i: &mut PatBox) {
        visit_pat_box_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_ident_mut(&mut self, i: &mut PatIdent) {
        visit_pat_ident_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_lit_mut(&mut self, i: &mut PatLit) {
        visit_pat_lit_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_macro_mut(&mut self, i: &mut PatMacro) {
        visit_pat_macro_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_path_mut(&mut self, i: &mut PatPath) {
        visit_pat_path_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_range_mut(&mut self, i: &mut PatRange) {
        visit_pat_range_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_ref_mut(&mut self, i: &mut PatRef) {
        visit_pat_ref_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_slice_mut(&mut self, i: &mut PatSlice) {
        visit_pat_slice_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_struct_mut(&mut self, i: &mut PatStruct) {
        visit_pat_struct_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_tuple_mut(&mut self, i: &mut PatTuple) {
        visit_pat_tuple_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_tuple_struct_mut(&mut self, i: &mut PatTupleStruct) {
        visit_pat_tuple_struct_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_verbatim_mut(&mut self, i: &mut PatVerbatim) {
        visit_pat_verbatim_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_wild_mut(&mut self, i: &mut PatWild) {
        visit_pat_wild_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_path_mut(&mut self, i: &mut Path) {
        visit_path_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_path_arguments_mut(&mut self, i: &mut PathArguments) {
        visit_path_arguments_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_path_segment_mut(&mut self, i: &mut PathSegment) {
        visit_path_segment_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_predicate_eq_mut(&mut self, i: &mut PredicateEq) {
        visit_predicate_eq_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_predicate_lifetime_mut(&mut self, i: &mut PredicateLifetime) {
        visit_predicate_lifetime_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_predicate_type_mut(&mut self, i: &mut PredicateType) {
        visit_predicate_type_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_qself_mut(&mut self, i: &mut QSelf) {
        visit_qself_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_range_limits_mut(&mut self, i: &mut RangeLimits) {
        visit_range_limits_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_return_type_mut(&mut self, i: &mut ReturnType) {
        visit_return_type_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_stmt_mut(&mut self, i: &mut Stmt) {
        visit_stmt_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_trait_bound_mut(&mut self, i: &mut TraitBound) {
        visit_trait_bound_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_trait_bound_modifier_mut(&mut self, i: &mut TraitBoundModifier) {
        visit_trait_bound_modifier_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_mut(&mut self, i: &mut TraitItem) {
        visit_trait_item_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_const_mut(&mut self, i: &mut TraitItemConst) {
        visit_trait_item_const_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_macro_mut(&mut self, i: &mut TraitItemMacro) {
        visit_trait_item_macro_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_method_mut(&mut self, i: &mut TraitItemMethod) {
        visit_trait_item_method_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_type_mut(&mut self, i: &mut TraitItemType) {
        visit_trait_item_type_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_verbatim_mut(&mut self, i: &mut TraitItemVerbatim) {
        visit_trait_item_verbatim_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_mut(&mut self, i: &mut Type) {
        visit_type_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_array_mut(&mut self, i: &mut TypeArray) {
        visit_type_array_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_bare_fn_mut(&mut self, i: &mut TypeBareFn) {
        visit_type_bare_fn_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_group_mut(&mut self, i: &mut TypeGroup) {
        visit_type_group_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_impl_trait_mut(&mut self, i: &mut TypeImplTrait) {
        visit_type_impl_trait_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_infer_mut(&mut self, i: &mut TypeInfer) {
        visit_type_infer_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_macro_mut(&mut self, i: &mut TypeMacro) {
        visit_type_macro_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_never_mut(&mut self, i: &mut TypeNever) {
        visit_type_never_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_param_mut(&mut self, i: &mut TypeParam) {
        visit_type_param_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_param_bound_mut(&mut self, i: &mut TypeParamBound) {
        visit_type_param_bound_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_paren_mut(&mut self, i: &mut TypeParen) {
        visit_type_paren_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_path_mut(&mut self, i: &mut TypePath) {
        visit_type_path_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_ptr_mut(&mut self, i: &mut TypePtr) {
        visit_type_ptr_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_reference_mut(&mut self, i: &mut TypeReference) {
        visit_type_reference_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_slice_mut(&mut self, i: &mut TypeSlice) {
        visit_type_slice_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_trait_object_mut(&mut self, i: &mut TypeTraitObject) {
        visit_type_trait_object_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_tuple_mut(&mut self, i: &mut TypeTuple) {
        visit_type_tuple_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_verbatim_mut(&mut self, i: &mut TypeVerbatim) {
        visit_type_verbatim_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_un_op_mut(&mut self, i: &mut UnOp) {
        visit_un_op_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_glob_mut(&mut self, i: &mut UseGlob) {
        visit_use_glob_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_group_mut(&mut self, i: &mut UseGroup) {
        visit_use_group_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_name_mut(&mut self, i: &mut UseName) {
        visit_use_name_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_path_mut(&mut self, i: &mut UsePath) {
        visit_use_path_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_rename_mut(&mut self, i: &mut UseRename) {
        visit_use_rename_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_tree_mut(&mut self, i: &mut UseTree) {
        visit_use_tree_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_variant_mut(&mut self, i: &mut Variant) {
        visit_variant_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_vis_crate_mut(&mut self, i: &mut VisCrate) {
        visit_vis_crate_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_vis_public_mut(&mut self, i: &mut VisPublic) {
        visit_vis_public_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_vis_restricted_mut(&mut self, i: &mut VisRestricted) {
        visit_vis_restricted_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_visibility_mut(&mut self, i: &mut Visibility) {
        visit_visibility_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_where_clause_mut(&mut self, i: &mut WhereClause) {
        visit_where_clause_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_where_predicate_mut(&mut self, i: &mut WherePredicate) {
        visit_where_predicate_mut(self, i)
    }
    fn visit_span_mut(&mut self, i: &mut Span) {
        visit_span_mut(self, i)
    }
    fn visit_ident_mut(&mut self, i: &mut Ident) {
        visit_ident_mut(self, i)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_abi_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Abi) {
    tokens_helper(_visitor, &mut _i.extern_token.span);
    if let Some(ref mut it) = _i.name {
        _visitor.visit_lit_str_mut(it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_angle_bracketed_generic_arguments_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut AngleBracketedGenericArguments,
) {
    if let Some(ref mut it) = _i.colon2_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    tokens_helper(_visitor, &mut _i.lt_token.spans);
    for mut el in Punctuated::pairs_mut(&mut _i.args) {
        let it = el.value_mut();
        _visitor.visit_generic_argument_mut(it)
    }
    tokens_helper(_visitor, &mut _i.gt_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_arg_captured_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ArgCaptured) {
    _visitor.visit_pat_mut(&mut _i.pat);
    tokens_helper(_visitor, &mut _i.colon_token.spans);
    _visitor.visit_type_mut(&mut _i.ty);
}
#[cfg(feature = "full")]
pub fn visit_arg_self_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ArgSelf) {
    if let Some(ref mut it) = _i.mutability {
        tokens_helper(_visitor, &mut it.span)
    };
    tokens_helper(_visitor, &mut _i.self_token.span);
}
#[cfg(feature = "full")]
pub fn visit_arg_self_ref_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ArgSelfRef) {
    tokens_helper(_visitor, &mut _i.and_token.spans);
    if let Some(ref mut it) = _i.lifetime {
        _visitor.visit_lifetime_mut(it)
    };
    if let Some(ref mut it) = _i.mutability {
        tokens_helper(_visitor, &mut it.span)
    };
    tokens_helper(_visitor, &mut _i.self_token.span);
}
#[cfg(feature = "full")]
pub fn visit_arm_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Arm) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    if let Some(ref mut it) = _i.leading_vert {
        tokens_helper(_visitor, &mut it.spans)
    };
    for mut el in Punctuated::pairs_mut(&mut _i.pats) {
        let it = el.value_mut();
        _visitor.visit_pat_mut(it)
    }
    if let Some(ref mut it) = _i.guard {
        tokens_helper(_visitor, &mut (it).0.span);
        _visitor.visit_expr_mut(&mut *(it).1);
    };
    tokens_helper(_visitor, &mut _i.fat_arrow_token.spans);
    _visitor.visit_expr_mut(&mut *_i.body);
    if let Some(ref mut it) = _i.comma {
        tokens_helper(_visitor, &mut it.spans)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_attr_style_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut AttrStyle) {
    match *_i {
        AttrStyle::Outer => {}
        AttrStyle::Inner(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_attribute_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Attribute) {
    tokens_helper(_visitor, &mut _i.pound_token.spans);
    _visitor.visit_attr_style_mut(&mut _i.style);
    tokens_helper(_visitor, &mut _i.bracket_token.span);
    _visitor.visit_path_mut(&mut _i.path);
    skip!(_i.tts);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_bare_fn_arg_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut BareFnArg) {
    if let Some(ref mut it) = _i.name {
        _visitor.visit_bare_fn_arg_name_mut(&mut (it).0);
        tokens_helper(_visitor, &mut (it).1.spans);
    };
    _visitor.visit_type_mut(&mut _i.ty);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_bare_fn_arg_name_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut BareFnArgName) {
    match *_i {
        BareFnArgName::Named(ref mut _binding_0) => {
            _visitor.visit_ident_mut(_binding_0);
        }
        BareFnArgName::Wild(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_bin_op_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut BinOp) {
    match *_i {
        BinOp::Add(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Sub(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Mul(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Div(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Rem(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::And(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Or(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::BitXor(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::BitAnd(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::BitOr(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Shl(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Shr(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Eq(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Lt(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Le(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Ne(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Ge(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::Gt(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::AddEq(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::SubEq(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::MulEq(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::DivEq(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::RemEq(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::BitXorEq(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::BitAndEq(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::BitOrEq(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::ShlEq(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        BinOp::ShrEq(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_binding_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Binding) {
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.eq_token.spans);
    _visitor.visit_type_mut(&mut _i.ty);
}
#[cfg(feature = "full")]
pub fn visit_block_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Block) {
    tokens_helper(_visitor, &mut _i.brace_token.span);
    for it in &mut _i.stmts {
        _visitor.visit_stmt_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_bound_lifetimes_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut BoundLifetimes) {
    tokens_helper(_visitor, &mut _i.for_token.span);
    tokens_helper(_visitor, &mut _i.lt_token.spans);
    for mut el in Punctuated::pairs_mut(&mut _i.lifetimes) {
        let it = el.value_mut();
        _visitor.visit_lifetime_def_mut(it)
    }
    tokens_helper(_visitor, &mut _i.gt_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_const_param_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ConstParam) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.const_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.colon_token.spans);
    _visitor.visit_type_mut(&mut _i.ty);
    if let Some(ref mut it) = _i.eq_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    if let Some(ref mut it) = _i.default {
        _visitor.visit_expr_mut(it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_constraint_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Constraint) {
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.colon_token.spans);
    for mut el in Punctuated::pairs_mut(&mut _i.bounds) {
        let it = el.value_mut();
        _visitor.visit_type_param_bound_mut(it)
    }
}
#[cfg(feature = "derive")]
pub fn visit_data_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Data) {
    match *_i {
        Data::Struct(ref mut _binding_0) => {
            _visitor.visit_data_struct_mut(_binding_0);
        }
        Data::Enum(ref mut _binding_0) => {
            _visitor.visit_data_enum_mut(_binding_0);
        }
        Data::Union(ref mut _binding_0) => {
            _visitor.visit_data_union_mut(_binding_0);
        }
    }
}
#[cfg(feature = "derive")]
pub fn visit_data_enum_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut DataEnum) {
    tokens_helper(_visitor, &mut _i.enum_token.span);
    tokens_helper(_visitor, &mut _i.brace_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.variants) {
        let it = el.value_mut();
        _visitor.visit_variant_mut(it)
    }
}
#[cfg(feature = "derive")]
pub fn visit_data_struct_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut DataStruct) {
    tokens_helper(_visitor, &mut _i.struct_token.span);
    _visitor.visit_fields_mut(&mut _i.fields);
    if let Some(ref mut it) = _i.semi_token {
        tokens_helper(_visitor, &mut it.spans)
    };
}
#[cfg(feature = "derive")]
pub fn visit_data_union_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut DataUnion) {
    tokens_helper(_visitor, &mut _i.union_token.span);
    _visitor.visit_fields_named_mut(&mut _i.fields);
}
#[cfg(feature = "derive")]
pub fn visit_derive_input_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut DeriveInput) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_generics_mut(&mut _i.generics);
    _visitor.visit_data_mut(&mut _i.data);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Expr) {
    match *_i {
        Expr::Box(ref mut _binding_0) => {
            full!(_visitor.visit_expr_box_mut(_binding_0));
        }
        Expr::InPlace(ref mut _binding_0) => {
            full!(_visitor.visit_expr_in_place_mut(_binding_0));
        }
        Expr::Array(ref mut _binding_0) => {
            full!(_visitor.visit_expr_array_mut(_binding_0));
        }
        Expr::Call(ref mut _binding_0) => {
            _visitor.visit_expr_call_mut(_binding_0);
        }
        Expr::MethodCall(ref mut _binding_0) => {
            full!(_visitor.visit_expr_method_call_mut(_binding_0));
        }
        Expr::Tuple(ref mut _binding_0) => {
            full!(_visitor.visit_expr_tuple_mut(_binding_0));
        }
        Expr::Binary(ref mut _binding_0) => {
            _visitor.visit_expr_binary_mut(_binding_0);
        }
        Expr::Unary(ref mut _binding_0) => {
            _visitor.visit_expr_unary_mut(_binding_0);
        }
        Expr::Lit(ref mut _binding_0) => {
            _visitor.visit_expr_lit_mut(_binding_0);
        }
        Expr::Cast(ref mut _binding_0) => {
            _visitor.visit_expr_cast_mut(_binding_0);
        }
        Expr::Type(ref mut _binding_0) => {
            full!(_visitor.visit_expr_type_mut(_binding_0));
        }
        Expr::Let(ref mut _binding_0) => {
            full!(_visitor.visit_expr_let_mut(_binding_0));
        }
        Expr::If(ref mut _binding_0) => {
            full!(_visitor.visit_expr_if_mut(_binding_0));
        }
        Expr::While(ref mut _binding_0) => {
            full!(_visitor.visit_expr_while_mut(_binding_0));
        }
        Expr::ForLoop(ref mut _binding_0) => {
            full!(_visitor.visit_expr_for_loop_mut(_binding_0));
        }
        Expr::Loop(ref mut _binding_0) => {
            full!(_visitor.visit_expr_loop_mut(_binding_0));
        }
        Expr::Match(ref mut _binding_0) => {
            full!(_visitor.visit_expr_match_mut(_binding_0));
        }
        Expr::Closure(ref mut _binding_0) => {
            full!(_visitor.visit_expr_closure_mut(_binding_0));
        }
        Expr::Unsafe(ref mut _binding_0) => {
            full!(_visitor.visit_expr_unsafe_mut(_binding_0));
        }
        Expr::Block(ref mut _binding_0) => {
            full!(_visitor.visit_expr_block_mut(_binding_0));
        }
        Expr::Assign(ref mut _binding_0) => {
            full!(_visitor.visit_expr_assign_mut(_binding_0));
        }
        Expr::AssignOp(ref mut _binding_0) => {
            full!(_visitor.visit_expr_assign_op_mut(_binding_0));
        }
        Expr::Field(ref mut _binding_0) => {
            _visitor.visit_expr_field_mut(_binding_0);
        }
        Expr::Index(ref mut _binding_0) => {
            _visitor.visit_expr_index_mut(_binding_0);
        }
        Expr::Range(ref mut _binding_0) => {
            full!(_visitor.visit_expr_range_mut(_binding_0));
        }
        Expr::Path(ref mut _binding_0) => {
            _visitor.visit_expr_path_mut(_binding_0);
        }
        Expr::Reference(ref mut _binding_0) => {
            full!(_visitor.visit_expr_reference_mut(_binding_0));
        }
        Expr::Break(ref mut _binding_0) => {
            full!(_visitor.visit_expr_break_mut(_binding_0));
        }
        Expr::Continue(ref mut _binding_0) => {
            full!(_visitor.visit_expr_continue_mut(_binding_0));
        }
        Expr::Return(ref mut _binding_0) => {
            full!(_visitor.visit_expr_return_mut(_binding_0));
        }
        Expr::Macro(ref mut _binding_0) => {
            full!(_visitor.visit_expr_macro_mut(_binding_0));
        }
        Expr::Struct(ref mut _binding_0) => {
            full!(_visitor.visit_expr_struct_mut(_binding_0));
        }
        Expr::Repeat(ref mut _binding_0) => {
            full!(_visitor.visit_expr_repeat_mut(_binding_0));
        }
        Expr::Paren(ref mut _binding_0) => {
            _visitor.visit_expr_paren_mut(_binding_0);
        }
        Expr::Group(ref mut _binding_0) => {
            full!(_visitor.visit_expr_group_mut(_binding_0));
        }
        Expr::Try(ref mut _binding_0) => {
            full!(_visitor.visit_expr_try_mut(_binding_0));
        }
        Expr::Async(ref mut _binding_0) => {
            full!(_visitor.visit_expr_async_mut(_binding_0));
        }
        Expr::TryBlock(ref mut _binding_0) => {
            full!(_visitor.visit_expr_try_block_mut(_binding_0));
        }
        Expr::Yield(ref mut _binding_0) => {
            full!(_visitor.visit_expr_yield_mut(_binding_0));
        }
        Expr::Verbatim(ref mut _binding_0) => {
            _visitor.visit_expr_verbatim_mut(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_expr_array_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprArray) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.bracket_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.elems) {
        let it = el.value_mut();
        _visitor.visit_expr_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_expr_assign_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprAssign) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_expr_mut(&mut *_i.left);
    tokens_helper(_visitor, &mut _i.eq_token.spans);
    _visitor.visit_expr_mut(&mut *_i.right);
}
#[cfg(feature = "full")]
pub fn visit_expr_assign_op_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprAssignOp) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_expr_mut(&mut *_i.left);
    _visitor.visit_bin_op_mut(&mut _i.op);
    _visitor.visit_expr_mut(&mut *_i.right);
}
#[cfg(feature = "full")]
pub fn visit_expr_async_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprAsync) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.async_token.span);
    if let Some(ref mut it) = _i.capture {
        tokens_helper(_visitor, &mut it.span)
    };
    _visitor.visit_block_mut(&mut _i.block);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_binary_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprBinary) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_expr_mut(&mut *_i.left);
    _visitor.visit_bin_op_mut(&mut _i.op);
    _visitor.visit_expr_mut(&mut *_i.right);
}
#[cfg(feature = "full")]
pub fn visit_expr_block_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprBlock) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    if let Some(ref mut it) = _i.label {
        _visitor.visit_label_mut(it)
    };
    _visitor.visit_block_mut(&mut _i.block);
}
#[cfg(feature = "full")]
pub fn visit_expr_box_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprBox) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.box_token.span);
    _visitor.visit_expr_mut(&mut *_i.expr);
}
#[cfg(feature = "full")]
pub fn visit_expr_break_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprBreak) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.break_token.span);
    if let Some(ref mut it) = _i.label {
        _visitor.visit_lifetime_mut(it)
    };
    if let Some(ref mut it) = _i.expr {
        _visitor.visit_expr_mut(&mut **it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_call_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprCall) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_expr_mut(&mut *_i.func);
    tokens_helper(_visitor, &mut _i.paren_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.args) {
        let it = el.value_mut();
        _visitor.visit_expr_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_cast_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprCast) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_expr_mut(&mut *_i.expr);
    tokens_helper(_visitor, &mut _i.as_token.span);
    _visitor.visit_type_mut(&mut *_i.ty);
}
#[cfg(feature = "full")]
pub fn visit_expr_closure_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprClosure) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    if let Some(ref mut it) = _i.asyncness {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.movability {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.capture {
        tokens_helper(_visitor, &mut it.span)
    };
    tokens_helper(_visitor, &mut _i.or1_token.spans);
    for mut el in Punctuated::pairs_mut(&mut _i.inputs) {
        let it = el.value_mut();
        _visitor.visit_fn_arg_mut(it)
    }
    tokens_helper(_visitor, &mut _i.or2_token.spans);
    _visitor.visit_return_type_mut(&mut _i.output);
    _visitor.visit_expr_mut(&mut *_i.body);
}
#[cfg(feature = "full")]
pub fn visit_expr_continue_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprContinue) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.continue_token.span);
    if let Some(ref mut it) = _i.label {
        _visitor.visit_lifetime_mut(it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_field_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprField) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_expr_mut(&mut *_i.base);
    tokens_helper(_visitor, &mut _i.dot_token.spans);
    _visitor.visit_member_mut(&mut _i.member);
}
#[cfg(feature = "full")]
pub fn visit_expr_for_loop_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprForLoop) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    if let Some(ref mut it) = _i.label {
        _visitor.visit_label_mut(it)
    };
    tokens_helper(_visitor, &mut _i.for_token.span);
    _visitor.visit_pat_mut(&mut *_i.pat);
    tokens_helper(_visitor, &mut _i.in_token.span);
    _visitor.visit_expr_mut(&mut *_i.expr);
    _visitor.visit_block_mut(&mut _i.body);
}
#[cfg(feature = "full")]
pub fn visit_expr_group_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprGroup) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.group_token.span);
    _visitor.visit_expr_mut(&mut *_i.expr);
}
#[cfg(feature = "full")]
pub fn visit_expr_if_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprIf) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.if_token.span);
    _visitor.visit_expr_mut(&mut *_i.cond);
    _visitor.visit_block_mut(&mut _i.then_branch);
    if let Some(ref mut it) = _i.else_branch {
        tokens_helper(_visitor, &mut (it).0.span);
        _visitor.visit_expr_mut(&mut *(it).1);
    };
}
#[cfg(feature = "full")]
pub fn visit_expr_in_place_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprInPlace) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_expr_mut(&mut *_i.place);
    tokens_helper(_visitor, &mut _i.arrow_token.spans);
    _visitor.visit_expr_mut(&mut *_i.value);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_index_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprIndex) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_expr_mut(&mut *_i.expr);
    tokens_helper(_visitor, &mut _i.bracket_token.span);
    _visitor.visit_expr_mut(&mut *_i.index);
}
#[cfg(feature = "full")]
pub fn visit_expr_let_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprLet) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.let_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.pats) {
        let it = el.value_mut();
        _visitor.visit_pat_mut(it)
    }
    tokens_helper(_visitor, &mut _i.eq_token.spans);
    _visitor.visit_expr_mut(&mut *_i.expr);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_lit_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprLit) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_lit_mut(&mut _i.lit);
}
#[cfg(feature = "full")]
pub fn visit_expr_loop_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprLoop) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    if let Some(ref mut it) = _i.label {
        _visitor.visit_label_mut(it)
    };
    tokens_helper(_visitor, &mut _i.loop_token.span);
    _visitor.visit_block_mut(&mut _i.body);
}
#[cfg(feature = "full")]
pub fn visit_expr_macro_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprMacro) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_macro_mut(&mut _i.mac);
}
#[cfg(feature = "full")]
pub fn visit_expr_match_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprMatch) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.match_token.span);
    _visitor.visit_expr_mut(&mut *_i.expr);
    tokens_helper(_visitor, &mut _i.brace_token.span);
    for it in &mut _i.arms {
        _visitor.visit_arm_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_expr_method_call_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprMethodCall) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_expr_mut(&mut *_i.receiver);
    tokens_helper(_visitor, &mut _i.dot_token.spans);
    _visitor.visit_ident_mut(&mut _i.method);
    if let Some(ref mut it) = _i.turbofish {
        _visitor.visit_method_turbofish_mut(it)
    };
    tokens_helper(_visitor, &mut _i.paren_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.args) {
        let it = el.value_mut();
        _visitor.visit_expr_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_paren_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprParen) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.paren_token.span);
    _visitor.visit_expr_mut(&mut *_i.expr);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_path_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprPath) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    if let Some(ref mut it) = _i.qself {
        _visitor.visit_qself_mut(it)
    };
    _visitor.visit_path_mut(&mut _i.path);
}
#[cfg(feature = "full")]
pub fn visit_expr_range_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprRange) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    if let Some(ref mut it) = _i.from {
        _visitor.visit_expr_mut(&mut **it)
    };
    _visitor.visit_range_limits_mut(&mut _i.limits);
    if let Some(ref mut it) = _i.to {
        _visitor.visit_expr_mut(&mut **it)
    };
}
#[cfg(feature = "full")]
pub fn visit_expr_reference_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprReference) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.and_token.spans);
    if let Some(ref mut it) = _i.mutability {
        tokens_helper(_visitor, &mut it.span)
    };
    _visitor.visit_expr_mut(&mut *_i.expr);
}
#[cfg(feature = "full")]
pub fn visit_expr_repeat_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprRepeat) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.bracket_token.span);
    _visitor.visit_expr_mut(&mut *_i.expr);
    tokens_helper(_visitor, &mut _i.semi_token.spans);
    _visitor.visit_expr_mut(&mut *_i.len);
}
#[cfg(feature = "full")]
pub fn visit_expr_return_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprReturn) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.return_token.span);
    if let Some(ref mut it) = _i.expr {
        _visitor.visit_expr_mut(&mut **it)
    };
}
#[cfg(feature = "full")]
pub fn visit_expr_struct_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprStruct) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_path_mut(&mut _i.path);
    tokens_helper(_visitor, &mut _i.brace_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.fields) {
        let it = el.value_mut();
        _visitor.visit_field_value_mut(it)
    }
    if let Some(ref mut it) = _i.dot2_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    if let Some(ref mut it) = _i.rest {
        _visitor.visit_expr_mut(&mut **it)
    };
}
#[cfg(feature = "full")]
pub fn visit_expr_try_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprTry) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_expr_mut(&mut *_i.expr);
    tokens_helper(_visitor, &mut _i.question_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_expr_try_block_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprTryBlock) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.try_token.span);
    _visitor.visit_block_mut(&mut _i.block);
}
#[cfg(feature = "full")]
pub fn visit_expr_tuple_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprTuple) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.paren_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.elems) {
        let it = el.value_mut();
        _visitor.visit_expr_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_expr_type_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprType) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_expr_mut(&mut *_i.expr);
    tokens_helper(_visitor, &mut _i.colon_token.spans);
    _visitor.visit_type_mut(&mut *_i.ty);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_unary_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprUnary) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_un_op_mut(&mut _i.op);
    _visitor.visit_expr_mut(&mut *_i.expr);
}
#[cfg(feature = "full")]
pub fn visit_expr_unsafe_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprUnsafe) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.unsafe_token.span);
    _visitor.visit_block_mut(&mut _i.block);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_verbatim_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprVerbatim) {
    skip!(_i.tts);
}
#[cfg(feature = "full")]
pub fn visit_expr_while_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprWhile) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    if let Some(ref mut it) = _i.label {
        _visitor.visit_label_mut(it)
    };
    tokens_helper(_visitor, &mut _i.while_token.span);
    _visitor.visit_expr_mut(&mut *_i.cond);
    _visitor.visit_block_mut(&mut _i.body);
}
#[cfg(feature = "full")]
pub fn visit_expr_yield_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ExprYield) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.yield_token.span);
    if let Some(ref mut it) = _i.expr {
        _visitor.visit_expr_mut(&mut **it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_field_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Field) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    if let Some(ref mut it) = _i.ident {
        _visitor.visit_ident_mut(it)
    };
    if let Some(ref mut it) = _i.colon_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    _visitor.visit_type_mut(&mut _i.ty);
}
#[cfg(feature = "full")]
pub fn visit_field_pat_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut FieldPat) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_member_mut(&mut _i.member);
    if let Some(ref mut it) = _i.colon_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    _visitor.visit_pat_mut(&mut *_i.pat);
}
#[cfg(feature = "full")]
pub fn visit_field_value_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut FieldValue) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_member_mut(&mut _i.member);
    if let Some(ref mut it) = _i.colon_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    _visitor.visit_expr_mut(&mut _i.expr);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_fields_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Fields) {
    match *_i {
        Fields::Named(ref mut _binding_0) => {
            _visitor.visit_fields_named_mut(_binding_0);
        }
        Fields::Unnamed(ref mut _binding_0) => {
            _visitor.visit_fields_unnamed_mut(_binding_0);
        }
        Fields::Unit => {}
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_fields_named_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut FieldsNamed) {
    tokens_helper(_visitor, &mut _i.brace_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.named) {
        let it = el.value_mut();
        _visitor.visit_field_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_fields_unnamed_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut FieldsUnnamed) {
    tokens_helper(_visitor, &mut _i.paren_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.unnamed) {
        let it = el.value_mut();
        _visitor.visit_field_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_file_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut File) {
    skip!(_i.shebang);
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    for it in &mut _i.items {
        _visitor.visit_item_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_fn_arg_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut FnArg) {
    match *_i {
        FnArg::SelfRef(ref mut _binding_0) => {
            _visitor.visit_arg_self_ref_mut(_binding_0);
        }
        FnArg::SelfValue(ref mut _binding_0) => {
            _visitor.visit_arg_self_mut(_binding_0);
        }
        FnArg::Captured(ref mut _binding_0) => {
            _visitor.visit_arg_captured_mut(_binding_0);
        }
        FnArg::Inferred(ref mut _binding_0) => {
            _visitor.visit_pat_mut(_binding_0);
        }
        FnArg::Ignored(ref mut _binding_0) => {
            _visitor.visit_type_mut(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_fn_decl_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut FnDecl) {
    tokens_helper(_visitor, &mut _i.fn_token.span);
    _visitor.visit_generics_mut(&mut _i.generics);
    tokens_helper(_visitor, &mut _i.paren_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.inputs) {
        let it = el.value_mut();
        _visitor.visit_fn_arg_mut(it)
    }
    if let Some(ref mut it) = _i.variadic {
        tokens_helper(_visitor, &mut it.spans)
    };
    _visitor.visit_return_type_mut(&mut _i.output);
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ForeignItem) {
    match *_i {
        ForeignItem::Fn(ref mut _binding_0) => {
            _visitor.visit_foreign_item_fn_mut(_binding_0);
        }
        ForeignItem::Static(ref mut _binding_0) => {
            _visitor.visit_foreign_item_static_mut(_binding_0);
        }
        ForeignItem::Type(ref mut _binding_0) => {
            _visitor.visit_foreign_item_type_mut(_binding_0);
        }
        ForeignItem::Macro(ref mut _binding_0) => {
            _visitor.visit_foreign_item_macro_mut(_binding_0);
        }
        ForeignItem::Verbatim(ref mut _binding_0) => {
            _visitor.visit_foreign_item_verbatim_mut(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_fn_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ForeignItemFn) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_fn_decl_mut(&mut *_i.decl);
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_macro_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut ForeignItemMacro,
) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_macro_mut(&mut _i.mac);
    if let Some(ref mut it) = _i.semi_token {
        tokens_helper(_visitor, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_static_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut ForeignItemStatic,
) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.static_token.span);
    if let Some(ref mut it) = _i.mutability {
        tokens_helper(_visitor, &mut it.span)
    };
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.colon_token.spans);
    _visitor.visit_type_mut(&mut *_i.ty);
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_type_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut ForeignItemType,
) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.type_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_verbatim_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut ForeignItemVerbatim,
) {
    skip!(_i.tts);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_generic_argument_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut GenericArgument,
) {
    match *_i {
        GenericArgument::Lifetime(ref mut _binding_0) => {
            _visitor.visit_lifetime_mut(_binding_0);
        }
        GenericArgument::Type(ref mut _binding_0) => {
            _visitor.visit_type_mut(_binding_0);
        }
        GenericArgument::Binding(ref mut _binding_0) => {
            _visitor.visit_binding_mut(_binding_0);
        }
        GenericArgument::Constraint(ref mut _binding_0) => {
            _visitor.visit_constraint_mut(_binding_0);
        }
        GenericArgument::Const(ref mut _binding_0) => {
            _visitor.visit_expr_mut(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_generic_method_argument_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut GenericMethodArgument,
) {
    match *_i {
        GenericMethodArgument::Type(ref mut _binding_0) => {
            _visitor.visit_type_mut(_binding_0);
        }
        GenericMethodArgument::Const(ref mut _binding_0) => {
            _visitor.visit_expr_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_generic_param_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut GenericParam) {
    match *_i {
        GenericParam::Type(ref mut _binding_0) => {
            _visitor.visit_type_param_mut(_binding_0);
        }
        GenericParam::Lifetime(ref mut _binding_0) => {
            _visitor.visit_lifetime_def_mut(_binding_0);
        }
        GenericParam::Const(ref mut _binding_0) => {
            _visitor.visit_const_param_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_generics_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Generics) {
    if let Some(ref mut it) = _i.lt_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    for mut el in Punctuated::pairs_mut(&mut _i.params) {
        let it = el.value_mut();
        _visitor.visit_generic_param_mut(it)
    }
    if let Some(ref mut it) = _i.gt_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    if let Some(ref mut it) = _i.where_clause {
        _visitor.visit_where_clause_mut(it)
    };
}
#[cfg(feature = "full")]
pub fn visit_impl_item_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ImplItem) {
    match *_i {
        ImplItem::Const(ref mut _binding_0) => {
            _visitor.visit_impl_item_const_mut(_binding_0);
        }
        ImplItem::Method(ref mut _binding_0) => {
            _visitor.visit_impl_item_method_mut(_binding_0);
        }
        ImplItem::Type(ref mut _binding_0) => {
            _visitor.visit_impl_item_type_mut(_binding_0);
        }
        ImplItem::Existential(ref mut _binding_0) => {
            _visitor.visit_impl_item_existential_mut(_binding_0);
        }
        ImplItem::Macro(ref mut _binding_0) => {
            _visitor.visit_impl_item_macro_mut(_binding_0);
        }
        ImplItem::Verbatim(ref mut _binding_0) => {
            _visitor.visit_impl_item_verbatim_mut(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_impl_item_const_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ImplItemConst) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    if let Some(ref mut it) = _i.defaultness {
        tokens_helper(_visitor, &mut it.span)
    };
    tokens_helper(_visitor, &mut _i.const_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.colon_token.spans);
    _visitor.visit_type_mut(&mut _i.ty);
    tokens_helper(_visitor, &mut _i.eq_token.spans);
    _visitor.visit_expr_mut(&mut _i.expr);
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_impl_item_existential_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut ImplItemExistential,
) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.existential_token.span);
    tokens_helper(_visitor, &mut _i.type_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_generics_mut(&mut _i.generics);
    if let Some(ref mut it) = _i.colon_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    for mut el in Punctuated::pairs_mut(&mut _i.bounds) {
        let it = el.value_mut();
        _visitor.visit_type_param_bound_mut(it)
    }
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_impl_item_macro_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ImplItemMacro) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_macro_mut(&mut _i.mac);
    if let Some(ref mut it) = _i.semi_token {
        tokens_helper(_visitor, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_impl_item_method_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ImplItemMethod) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    if let Some(ref mut it) = _i.defaultness {
        tokens_helper(_visitor, &mut it.span)
    };
    _visitor.visit_method_sig_mut(&mut _i.sig);
    _visitor.visit_block_mut(&mut _i.block);
}
#[cfg(feature = "full")]
pub fn visit_impl_item_type_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ImplItemType) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    if let Some(ref mut it) = _i.defaultness {
        tokens_helper(_visitor, &mut it.span)
    };
    tokens_helper(_visitor, &mut _i.type_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_generics_mut(&mut _i.generics);
    tokens_helper(_visitor, &mut _i.eq_token.spans);
    _visitor.visit_type_mut(&mut _i.ty);
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_impl_item_verbatim_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut ImplItemVerbatim,
) {
    skip!(_i.tts);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_index_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Index) {
    skip!(_i.index);
    _visitor.visit_span_mut(&mut _i.span);
}
#[cfg(feature = "full")]
pub fn visit_item_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Item) {
    match *_i {
        Item::ExternCrate(ref mut _binding_0) => {
            _visitor.visit_item_extern_crate_mut(_binding_0);
        }
        Item::Use(ref mut _binding_0) => {
            _visitor.visit_item_use_mut(_binding_0);
        }
        Item::Static(ref mut _binding_0) => {
            _visitor.visit_item_static_mut(_binding_0);
        }
        Item::Const(ref mut _binding_0) => {
            _visitor.visit_item_const_mut(_binding_0);
        }
        Item::Fn(ref mut _binding_0) => {
            _visitor.visit_item_fn_mut(_binding_0);
        }
        Item::Mod(ref mut _binding_0) => {
            _visitor.visit_item_mod_mut(_binding_0);
        }
        Item::ForeignMod(ref mut _binding_0) => {
            _visitor.visit_item_foreign_mod_mut(_binding_0);
        }
        Item::Type(ref mut _binding_0) => {
            _visitor.visit_item_type_mut(_binding_0);
        }
        Item::Existential(ref mut _binding_0) => {
            _visitor.visit_item_existential_mut(_binding_0);
        }
        Item::Struct(ref mut _binding_0) => {
            _visitor.visit_item_struct_mut(_binding_0);
        }
        Item::Enum(ref mut _binding_0) => {
            _visitor.visit_item_enum_mut(_binding_0);
        }
        Item::Union(ref mut _binding_0) => {
            _visitor.visit_item_union_mut(_binding_0);
        }
        Item::Trait(ref mut _binding_0) => {
            _visitor.visit_item_trait_mut(_binding_0);
        }
        Item::TraitAlias(ref mut _binding_0) => {
            _visitor.visit_item_trait_alias_mut(_binding_0);
        }
        Item::Impl(ref mut _binding_0) => {
            _visitor.visit_item_impl_mut(_binding_0);
        }
        Item::Macro(ref mut _binding_0) => {
            _visitor.visit_item_macro_mut(_binding_0);
        }
        Item::Macro2(ref mut _binding_0) => {
            _visitor.visit_item_macro2_mut(_binding_0);
        }
        Item::Verbatim(ref mut _binding_0) => {
            _visitor.visit_item_verbatim_mut(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_item_const_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemConst) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.const_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.colon_token.spans);
    _visitor.visit_type_mut(&mut *_i.ty);
    tokens_helper(_visitor, &mut _i.eq_token.spans);
    _visitor.visit_expr_mut(&mut *_i.expr);
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_enum_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemEnum) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.enum_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_generics_mut(&mut _i.generics);
    tokens_helper(_visitor, &mut _i.brace_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.variants) {
        let it = el.value_mut();
        _visitor.visit_variant_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_item_existential_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut ItemExistential,
) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.existential_token.span);
    tokens_helper(_visitor, &mut _i.type_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_generics_mut(&mut _i.generics);
    if let Some(ref mut it) = _i.colon_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    for mut el in Punctuated::pairs_mut(&mut _i.bounds) {
        let it = el.value_mut();
        _visitor.visit_type_param_bound_mut(it)
    }
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_extern_crate_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut ItemExternCrate,
) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.extern_token.span);
    tokens_helper(_visitor, &mut _i.crate_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    if let Some(ref mut it) = _i.rename {
        tokens_helper(_visitor, &mut (it).0.span);
        _visitor.visit_ident_mut(&mut (it).1);
    };
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_fn_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemFn) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    if let Some(ref mut it) = _i.constness {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.unsafety {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.asyncness {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.abi {
        _visitor.visit_abi_mut(it)
    };
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_fn_decl_mut(&mut *_i.decl);
    _visitor.visit_block_mut(&mut *_i.block);
}
#[cfg(feature = "full")]
pub fn visit_item_foreign_mod_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemForeignMod) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_abi_mut(&mut _i.abi);
    tokens_helper(_visitor, &mut _i.brace_token.span);
    for it in &mut _i.items {
        _visitor.visit_foreign_item_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_item_impl_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemImpl) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    if let Some(ref mut it) = _i.defaultness {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.unsafety {
        tokens_helper(_visitor, &mut it.span)
    };
    tokens_helper(_visitor, &mut _i.impl_token.span);
    _visitor.visit_generics_mut(&mut _i.generics);
    if let Some(ref mut it) = _i.trait_ {
        if let Some(ref mut it) = (it).0 {
            tokens_helper(_visitor, &mut it.spans)
        };
        _visitor.visit_path_mut(&mut (it).1);
        tokens_helper(_visitor, &mut (it).2.span);
    };
    _visitor.visit_type_mut(&mut *_i.self_ty);
    tokens_helper(_visitor, &mut _i.brace_token.span);
    for it in &mut _i.items {
        _visitor.visit_impl_item_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_item_macro_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemMacro) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    if let Some(ref mut it) = _i.ident {
        _visitor.visit_ident_mut(it)
    };
    _visitor.visit_macro_mut(&mut _i.mac);
    if let Some(ref mut it) = _i.semi_token {
        tokens_helper(_visitor, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_item_macro2_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemMacro2) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.macro_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.paren_token.span);
    skip!(_i.args);
    tokens_helper(_visitor, &mut _i.brace_token.span);
    skip!(_i.body);
}
#[cfg(feature = "full")]
pub fn visit_item_mod_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemMod) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.mod_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    if let Some(ref mut it) = _i.content {
        tokens_helper(_visitor, &mut (it).0.span);
        for it in &mut (it).1 {
            _visitor.visit_item_mut(it)
        }
    };
    if let Some(ref mut it) = _i.semi {
        tokens_helper(_visitor, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_item_static_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemStatic) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.static_token.span);
    if let Some(ref mut it) = _i.mutability {
        tokens_helper(_visitor, &mut it.span)
    };
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.colon_token.spans);
    _visitor.visit_type_mut(&mut *_i.ty);
    tokens_helper(_visitor, &mut _i.eq_token.spans);
    _visitor.visit_expr_mut(&mut *_i.expr);
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_struct_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemStruct) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.struct_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_generics_mut(&mut _i.generics);
    _visitor.visit_fields_mut(&mut _i.fields);
    if let Some(ref mut it) = _i.semi_token {
        tokens_helper(_visitor, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_item_trait_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemTrait) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    if let Some(ref mut it) = _i.unsafety {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.auto_token {
        tokens_helper(_visitor, &mut it.span)
    };
    tokens_helper(_visitor, &mut _i.trait_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_generics_mut(&mut _i.generics);
    if let Some(ref mut it) = _i.colon_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    for mut el in Punctuated::pairs_mut(&mut _i.supertraits) {
        let it = el.value_mut();
        _visitor.visit_type_param_bound_mut(it)
    }
    tokens_helper(_visitor, &mut _i.brace_token.span);
    for it in &mut _i.items {
        _visitor.visit_trait_item_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_item_trait_alias_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemTraitAlias) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.trait_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_generics_mut(&mut _i.generics);
    tokens_helper(_visitor, &mut _i.eq_token.spans);
    for mut el in Punctuated::pairs_mut(&mut _i.bounds) {
        let it = el.value_mut();
        _visitor.visit_type_param_bound_mut(it)
    }
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_type_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemType) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.type_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_generics_mut(&mut _i.generics);
    tokens_helper(_visitor, &mut _i.eq_token.spans);
    _visitor.visit_type_mut(&mut *_i.ty);
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_union_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemUnion) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.union_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_generics_mut(&mut _i.generics);
    _visitor.visit_fields_named_mut(&mut _i.fields);
}
#[cfg(feature = "full")]
pub fn visit_item_use_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemUse) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_visibility_mut(&mut _i.vis);
    tokens_helper(_visitor, &mut _i.use_token.span);
    if let Some(ref mut it) = _i.leading_colon {
        tokens_helper(_visitor, &mut it.spans)
    };
    _visitor.visit_use_tree_mut(&mut _i.tree);
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_verbatim_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ItemVerbatim) {
    skip!(_i.tts);
}
#[cfg(feature = "full")]
pub fn visit_label_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Label) {
    _visitor.visit_lifetime_mut(&mut _i.name);
    tokens_helper(_visitor, &mut _i.colon_token.spans);
}
pub fn visit_lifetime_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Lifetime) {
    _visitor.visit_span_mut(&mut _i.apostrophe);
    _visitor.visit_ident_mut(&mut _i.ident);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lifetime_def_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut LifetimeDef) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_lifetime_mut(&mut _i.lifetime);
    if let Some(ref mut it) = _i.colon_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    for mut el in Punctuated::pairs_mut(&mut _i.bounds) {
        let it = el.value_mut();
        _visitor.visit_lifetime_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Lit) {
    match *_i {
        Lit::Str(ref mut _binding_0) => {
            _visitor.visit_lit_str_mut(_binding_0);
        }
        Lit::ByteStr(ref mut _binding_0) => {
            _visitor.visit_lit_byte_str_mut(_binding_0);
        }
        Lit::Byte(ref mut _binding_0) => {
            _visitor.visit_lit_byte_mut(_binding_0);
        }
        Lit::Char(ref mut _binding_0) => {
            _visitor.visit_lit_char_mut(_binding_0);
        }
        Lit::Int(ref mut _binding_0) => {
            _visitor.visit_lit_int_mut(_binding_0);
        }
        Lit::Float(ref mut _binding_0) => {
            _visitor.visit_lit_float_mut(_binding_0);
        }
        Lit::Bool(ref mut _binding_0) => {
            _visitor.visit_lit_bool_mut(_binding_0);
        }
        Lit::Verbatim(ref mut _binding_0) => {
            _visitor.visit_lit_verbatim_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_bool_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut LitBool) {
    skip!(_i.value);
    _visitor.visit_span_mut(&mut _i.span);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_byte_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut LitByte) {}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_byte_str_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut LitByteStr) {}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_char_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut LitChar) {}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_float_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut LitFloat) {}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_int_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut LitInt) {}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_str_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut LitStr) {}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lit_verbatim_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut LitVerbatim) {
    skip!(_i.token);
}
#[cfg(feature = "full")]
pub fn visit_local_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Local) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.let_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.pats) {
        let it = el.value_mut();
        _visitor.visit_pat_mut(it)
    }
    if let Some(ref mut it) = _i.ty {
        tokens_helper(_visitor, &mut (it).0.spans);
        _visitor.visit_type_mut(&mut *(it).1);
    };
    if let Some(ref mut it) = _i.init {
        tokens_helper(_visitor, &mut (it).0.spans);
        _visitor.visit_expr_mut(&mut *(it).1);
    };
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_macro_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Macro) {
    _visitor.visit_path_mut(&mut _i.path);
    tokens_helper(_visitor, &mut _i.bang_token.spans);
    _visitor.visit_macro_delimiter_mut(&mut _i.delimiter);
    skip!(_i.tts);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_macro_delimiter_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut MacroDelimiter) {
    match *_i {
        MacroDelimiter::Paren(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.span);
        }
        MacroDelimiter::Brace(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.span);
        }
        MacroDelimiter::Bracket(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.span);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_member_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Member) {
    match *_i {
        Member::Named(ref mut _binding_0) => {
            _visitor.visit_ident_mut(_binding_0);
        }
        Member::Unnamed(ref mut _binding_0) => {
            _visitor.visit_index_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_meta_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Meta) {
    match *_i {
        Meta::Word(ref mut _binding_0) => {
            _visitor.visit_ident_mut(_binding_0);
        }
        Meta::List(ref mut _binding_0) => {
            _visitor.visit_meta_list_mut(_binding_0);
        }
        Meta::NameValue(ref mut _binding_0) => {
            _visitor.visit_meta_name_value_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_meta_list_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut MetaList) {
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.paren_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.nested) {
        let it = el.value_mut();
        _visitor.visit_nested_meta_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_meta_name_value_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut MetaNameValue) {
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.eq_token.spans);
    _visitor.visit_lit_mut(&mut _i.lit);
}
#[cfg(feature = "full")]
pub fn visit_method_sig_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut MethodSig) {
    if let Some(ref mut it) = _i.constness {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.unsafety {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.asyncness {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.abi {
        _visitor.visit_abi_mut(it)
    };
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_fn_decl_mut(&mut _i.decl);
}
#[cfg(feature = "full")]
pub fn visit_method_turbofish_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut MethodTurbofish,
) {
    tokens_helper(_visitor, &mut _i.colon2_token.spans);
    tokens_helper(_visitor, &mut _i.lt_token.spans);
    for mut el in Punctuated::pairs_mut(&mut _i.args) {
        let it = el.value_mut();
        _visitor.visit_generic_method_argument_mut(it)
    }
    tokens_helper(_visitor, &mut _i.gt_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_nested_meta_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut NestedMeta) {
    match *_i {
        NestedMeta::Meta(ref mut _binding_0) => {
            _visitor.visit_meta_mut(_binding_0);
        }
        NestedMeta::Literal(ref mut _binding_0) => {
            _visitor.visit_lit_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_parenthesized_generic_arguments_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut ParenthesizedGenericArguments,
) {
    tokens_helper(_visitor, &mut _i.paren_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.inputs) {
        let it = el.value_mut();
        _visitor.visit_type_mut(it)
    }
    _visitor.visit_return_type_mut(&mut _i.output);
}
#[cfg(feature = "full")]
pub fn visit_pat_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Pat) {
    match *_i {
        Pat::Wild(ref mut _binding_0) => {
            _visitor.visit_pat_wild_mut(_binding_0);
        }
        Pat::Ident(ref mut _binding_0) => {
            _visitor.visit_pat_ident_mut(_binding_0);
        }
        Pat::Struct(ref mut _binding_0) => {
            _visitor.visit_pat_struct_mut(_binding_0);
        }
        Pat::TupleStruct(ref mut _binding_0) => {
            _visitor.visit_pat_tuple_struct_mut(_binding_0);
        }
        Pat::Path(ref mut _binding_0) => {
            _visitor.visit_pat_path_mut(_binding_0);
        }
        Pat::Tuple(ref mut _binding_0) => {
            _visitor.visit_pat_tuple_mut(_binding_0);
        }
        Pat::Box(ref mut _binding_0) => {
            _visitor.visit_pat_box_mut(_binding_0);
        }
        Pat::Ref(ref mut _binding_0) => {
            _visitor.visit_pat_ref_mut(_binding_0);
        }
        Pat::Lit(ref mut _binding_0) => {
            _visitor.visit_pat_lit_mut(_binding_0);
        }
        Pat::Range(ref mut _binding_0) => {
            _visitor.visit_pat_range_mut(_binding_0);
        }
        Pat::Slice(ref mut _binding_0) => {
            _visitor.visit_pat_slice_mut(_binding_0);
        }
        Pat::Macro(ref mut _binding_0) => {
            _visitor.visit_pat_macro_mut(_binding_0);
        }
        Pat::Verbatim(ref mut _binding_0) => {
            _visitor.visit_pat_verbatim_mut(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_pat_box_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatBox) {
    tokens_helper(_visitor, &mut _i.box_token.span);
    _visitor.visit_pat_mut(&mut *_i.pat);
}
#[cfg(feature = "full")]
pub fn visit_pat_ident_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatIdent) {
    if let Some(ref mut it) = _i.by_ref {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.mutability {
        tokens_helper(_visitor, &mut it.span)
    };
    _visitor.visit_ident_mut(&mut _i.ident);
    if let Some(ref mut it) = _i.subpat {
        tokens_helper(_visitor, &mut (it).0.spans);
        _visitor.visit_pat_mut(&mut *(it).1);
    };
}
#[cfg(feature = "full")]
pub fn visit_pat_lit_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatLit) {
    _visitor.visit_expr_mut(&mut *_i.expr);
}
#[cfg(feature = "full")]
pub fn visit_pat_macro_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatMacro) {
    _visitor.visit_macro_mut(&mut _i.mac);
}
#[cfg(feature = "full")]
pub fn visit_pat_path_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatPath) {
    if let Some(ref mut it) = _i.qself {
        _visitor.visit_qself_mut(it)
    };
    _visitor.visit_path_mut(&mut _i.path);
}
#[cfg(feature = "full")]
pub fn visit_pat_range_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatRange) {
    _visitor.visit_expr_mut(&mut *_i.lo);
    _visitor.visit_range_limits_mut(&mut _i.limits);
    _visitor.visit_expr_mut(&mut *_i.hi);
}
#[cfg(feature = "full")]
pub fn visit_pat_ref_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatRef) {
    tokens_helper(_visitor, &mut _i.and_token.spans);
    if let Some(ref mut it) = _i.mutability {
        tokens_helper(_visitor, &mut it.span)
    };
    _visitor.visit_pat_mut(&mut *_i.pat);
}
#[cfg(feature = "full")]
pub fn visit_pat_slice_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatSlice) {
    tokens_helper(_visitor, &mut _i.bracket_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.front) {
        let it = el.value_mut();
        _visitor.visit_pat_mut(it)
    }
    if let Some(ref mut it) = _i.middle {
        _visitor.visit_pat_mut(&mut **it)
    };
    if let Some(ref mut it) = _i.dot2_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    if let Some(ref mut it) = _i.comma_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    for mut el in Punctuated::pairs_mut(&mut _i.back) {
        let it = el.value_mut();
        _visitor.visit_pat_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_pat_struct_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatStruct) {
    _visitor.visit_path_mut(&mut _i.path);
    tokens_helper(_visitor, &mut _i.brace_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.fields) {
        let it = el.value_mut();
        _visitor.visit_field_pat_mut(it)
    }
    if let Some(ref mut it) = _i.dot2_token {
        tokens_helper(_visitor, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_pat_tuple_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatTuple) {
    tokens_helper(_visitor, &mut _i.paren_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.front) {
        let it = el.value_mut();
        _visitor.visit_pat_mut(it)
    }
    if let Some(ref mut it) = _i.dot2_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    if let Some(ref mut it) = _i.comma_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    for mut el in Punctuated::pairs_mut(&mut _i.back) {
        let it = el.value_mut();
        _visitor.visit_pat_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_pat_tuple_struct_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatTupleStruct) {
    _visitor.visit_path_mut(&mut _i.path);
    _visitor.visit_pat_tuple_mut(&mut _i.pat);
}
#[cfg(feature = "full")]
pub fn visit_pat_verbatim_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatVerbatim) {
    skip!(_i.tts);
}
#[cfg(feature = "full")]
pub fn visit_pat_wild_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PatWild) {
    tokens_helper(_visitor, &mut _i.underscore_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_path_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Path) {
    if let Some(ref mut it) = _i.leading_colon {
        tokens_helper(_visitor, &mut it.spans)
    };
    for mut el in Punctuated::pairs_mut(&mut _i.segments) {
        let it = el.value_mut();
        _visitor.visit_path_segment_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_path_arguments_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PathArguments) {
    match *_i {
        PathArguments::None => {}
        PathArguments::AngleBracketed(ref mut _binding_0) => {
            _visitor.visit_angle_bracketed_generic_arguments_mut(_binding_0);
        }
        PathArguments::Parenthesized(ref mut _binding_0) => {
            _visitor.visit_parenthesized_generic_arguments_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_path_segment_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PathSegment) {
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_path_arguments_mut(&mut _i.arguments);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_predicate_eq_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PredicateEq) {
    _visitor.visit_type_mut(&mut _i.lhs_ty);
    tokens_helper(_visitor, &mut _i.eq_token.spans);
    _visitor.visit_type_mut(&mut _i.rhs_ty);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_predicate_lifetime_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut PredicateLifetime,
) {
    _visitor.visit_lifetime_mut(&mut _i.lifetime);
    tokens_helper(_visitor, &mut _i.colon_token.spans);
    for mut el in Punctuated::pairs_mut(&mut _i.bounds) {
        let it = el.value_mut();
        _visitor.visit_lifetime_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_predicate_type_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut PredicateType) {
    if let Some(ref mut it) = _i.lifetimes {
        _visitor.visit_bound_lifetimes_mut(it)
    };
    _visitor.visit_type_mut(&mut _i.bounded_ty);
    tokens_helper(_visitor, &mut _i.colon_token.spans);
    for mut el in Punctuated::pairs_mut(&mut _i.bounds) {
        let it = el.value_mut();
        _visitor.visit_type_param_bound_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_qself_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut QSelf) {
    tokens_helper(_visitor, &mut _i.lt_token.spans);
    _visitor.visit_type_mut(&mut *_i.ty);
    skip!(_i.position);
    if let Some(ref mut it) = _i.as_token {
        tokens_helper(_visitor, &mut it.span)
    };
    tokens_helper(_visitor, &mut _i.gt_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_range_limits_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut RangeLimits) {
    match *_i {
        RangeLimits::HalfOpen(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        RangeLimits::Closed(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_return_type_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut ReturnType) {
    match *_i {
        ReturnType::Default => {}
        ReturnType::Type(ref mut _binding_0, ref mut _binding_1) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
            _visitor.visit_type_mut(&mut **_binding_1);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_stmt_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Stmt) {
    match *_i {
        Stmt::Local(ref mut _binding_0) => {
            _visitor.visit_local_mut(_binding_0);
        }
        Stmt::Item(ref mut _binding_0) => {
            _visitor.visit_item_mut(_binding_0);
        }
        Stmt::Expr(ref mut _binding_0) => {
            _visitor.visit_expr_mut(_binding_0);
        }
        Stmt::Semi(ref mut _binding_0, ref mut _binding_1) => {
            _visitor.visit_expr_mut(_binding_0);
            tokens_helper(_visitor, &mut _binding_1.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_trait_bound_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TraitBound) {
    if let Some(ref mut it) = _i.paren_token {
        tokens_helper(_visitor, &mut it.span)
    };
    _visitor.visit_trait_bound_modifier_mut(&mut _i.modifier);
    if let Some(ref mut it) = _i.lifetimes {
        _visitor.visit_bound_lifetimes_mut(it)
    };
    _visitor.visit_path_mut(&mut _i.path);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_trait_bound_modifier_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut TraitBoundModifier,
) {
    match *_i {
        TraitBoundModifier::None => {}
        TraitBoundModifier::Maybe(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_trait_item_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TraitItem) {
    match *_i {
        TraitItem::Const(ref mut _binding_0) => {
            _visitor.visit_trait_item_const_mut(_binding_0);
        }
        TraitItem::Method(ref mut _binding_0) => {
            _visitor.visit_trait_item_method_mut(_binding_0);
        }
        TraitItem::Type(ref mut _binding_0) => {
            _visitor.visit_trait_item_type_mut(_binding_0);
        }
        TraitItem::Macro(ref mut _binding_0) => {
            _visitor.visit_trait_item_macro_mut(_binding_0);
        }
        TraitItem::Verbatim(ref mut _binding_0) => {
            _visitor.visit_trait_item_verbatim_mut(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_trait_item_const_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TraitItemConst) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.const_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.colon_token.spans);
    _visitor.visit_type_mut(&mut _i.ty);
    if let Some(ref mut it) = _i.default {
        tokens_helper(_visitor, &mut (it).0.spans);
        _visitor.visit_expr_mut(&mut (it).1);
    };
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_trait_item_macro_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TraitItemMacro) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_macro_mut(&mut _i.mac);
    if let Some(ref mut it) = _i.semi_token {
        tokens_helper(_visitor, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_trait_item_method_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut TraitItemMethod,
) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_method_sig_mut(&mut _i.sig);
    if let Some(ref mut it) = _i.default {
        _visitor.visit_block_mut(it)
    };
    if let Some(ref mut it) = _i.semi_token {
        tokens_helper(_visitor, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_trait_item_type_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TraitItemType) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    tokens_helper(_visitor, &mut _i.type_token.span);
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_generics_mut(&mut _i.generics);
    if let Some(ref mut it) = _i.colon_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    for mut el in Punctuated::pairs_mut(&mut _i.bounds) {
        let it = el.value_mut();
        _visitor.visit_type_param_bound_mut(it)
    }
    if let Some(ref mut it) = _i.default {
        tokens_helper(_visitor, &mut (it).0.spans);
        _visitor.visit_type_mut(&mut (it).1);
    };
    tokens_helper(_visitor, &mut _i.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_trait_item_verbatim_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut TraitItemVerbatim,
) {
    skip!(_i.tts);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Type) {
    match *_i {
        Type::Slice(ref mut _binding_0) => {
            _visitor.visit_type_slice_mut(_binding_0);
        }
        Type::Array(ref mut _binding_0) => {
            _visitor.visit_type_array_mut(_binding_0);
        }
        Type::Ptr(ref mut _binding_0) => {
            _visitor.visit_type_ptr_mut(_binding_0);
        }
        Type::Reference(ref mut _binding_0) => {
            _visitor.visit_type_reference_mut(_binding_0);
        }
        Type::BareFn(ref mut _binding_0) => {
            _visitor.visit_type_bare_fn_mut(_binding_0);
        }
        Type::Never(ref mut _binding_0) => {
            _visitor.visit_type_never_mut(_binding_0);
        }
        Type::Tuple(ref mut _binding_0) => {
            _visitor.visit_type_tuple_mut(_binding_0);
        }
        Type::Path(ref mut _binding_0) => {
            _visitor.visit_type_path_mut(_binding_0);
        }
        Type::TraitObject(ref mut _binding_0) => {
            _visitor.visit_type_trait_object_mut(_binding_0);
        }
        Type::ImplTrait(ref mut _binding_0) => {
            _visitor.visit_type_impl_trait_mut(_binding_0);
        }
        Type::Paren(ref mut _binding_0) => {
            _visitor.visit_type_paren_mut(_binding_0);
        }
        Type::Group(ref mut _binding_0) => {
            _visitor.visit_type_group_mut(_binding_0);
        }
        Type::Infer(ref mut _binding_0) => {
            _visitor.visit_type_infer_mut(_binding_0);
        }
        Type::Macro(ref mut _binding_0) => {
            _visitor.visit_type_macro_mut(_binding_0);
        }
        Type::Verbatim(ref mut _binding_0) => {
            _visitor.visit_type_verbatim_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_array_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeArray) {
    tokens_helper(_visitor, &mut _i.bracket_token.span);
    _visitor.visit_type_mut(&mut *_i.elem);
    tokens_helper(_visitor, &mut _i.semi_token.spans);
    _visitor.visit_expr_mut(&mut _i.len);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_bare_fn_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeBareFn) {
    if let Some(ref mut it) = _i.lifetimes {
        _visitor.visit_bound_lifetimes_mut(it)
    };
    if let Some(ref mut it) = _i.unsafety {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.abi {
        _visitor.visit_abi_mut(it)
    };
    tokens_helper(_visitor, &mut _i.fn_token.span);
    tokens_helper(_visitor, &mut _i.paren_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.inputs) {
        let it = el.value_mut();
        _visitor.visit_bare_fn_arg_mut(it)
    }
    if let Some(ref mut it) = _i.variadic {
        tokens_helper(_visitor, &mut it.spans)
    };
    _visitor.visit_return_type_mut(&mut _i.output);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_group_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeGroup) {
    tokens_helper(_visitor, &mut _i.group_token.span);
    _visitor.visit_type_mut(&mut *_i.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_impl_trait_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeImplTrait) {
    tokens_helper(_visitor, &mut _i.impl_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.bounds) {
        let it = el.value_mut();
        _visitor.visit_type_param_bound_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_infer_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeInfer) {
    tokens_helper(_visitor, &mut _i.underscore_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_macro_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeMacro) {
    _visitor.visit_macro_mut(&mut _i.mac);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_never_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeNever) {
    tokens_helper(_visitor, &mut _i.bang_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_param_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeParam) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_ident_mut(&mut _i.ident);
    if let Some(ref mut it) = _i.colon_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    for mut el in Punctuated::pairs_mut(&mut _i.bounds) {
        let it = el.value_mut();
        _visitor.visit_type_param_bound_mut(it)
    }
    if let Some(ref mut it) = _i.eq_token {
        tokens_helper(_visitor, &mut it.spans)
    };
    if let Some(ref mut it) = _i.default {
        _visitor.visit_type_mut(it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_param_bound_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeParamBound) {
    match *_i {
        TypeParamBound::Trait(ref mut _binding_0) => {
            _visitor.visit_trait_bound_mut(_binding_0);
        }
        TypeParamBound::Lifetime(ref mut _binding_0) => {
            _visitor.visit_lifetime_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_paren_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeParen) {
    tokens_helper(_visitor, &mut _i.paren_token.span);
    _visitor.visit_type_mut(&mut *_i.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_path_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypePath) {
    if let Some(ref mut it) = _i.qself {
        _visitor.visit_qself_mut(it)
    };
    _visitor.visit_path_mut(&mut _i.path);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_ptr_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypePtr) {
    tokens_helper(_visitor, &mut _i.star_token.spans);
    if let Some(ref mut it) = _i.const_token {
        tokens_helper(_visitor, &mut it.span)
    };
    if let Some(ref mut it) = _i.mutability {
        tokens_helper(_visitor, &mut it.span)
    };
    _visitor.visit_type_mut(&mut *_i.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_reference_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeReference) {
    tokens_helper(_visitor, &mut _i.and_token.spans);
    if let Some(ref mut it) = _i.lifetime {
        _visitor.visit_lifetime_mut(it)
    };
    if let Some(ref mut it) = _i.mutability {
        tokens_helper(_visitor, &mut it.span)
    };
    _visitor.visit_type_mut(&mut *_i.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_slice_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeSlice) {
    tokens_helper(_visitor, &mut _i.bracket_token.span);
    _visitor.visit_type_mut(&mut *_i.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_trait_object_mut<V: VisitMut + ?Sized>(
    _visitor: &mut V,
    _i: &mut TypeTraitObject,
) {
    if let Some(ref mut it) = _i.dyn_token {
        tokens_helper(_visitor, &mut it.span)
    };
    for mut el in Punctuated::pairs_mut(&mut _i.bounds) {
        let it = el.value_mut();
        _visitor.visit_type_param_bound_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_tuple_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeTuple) {
    tokens_helper(_visitor, &mut _i.paren_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.elems) {
        let it = el.value_mut();
        _visitor.visit_type_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_verbatim_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut TypeVerbatim) {
    skip!(_i.tts);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_un_op_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut UnOp) {
    match *_i {
        UnOp::Deref(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        UnOp::Not(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
        UnOp::Neg(ref mut _binding_0) => {
            tokens_helper(_visitor, &mut _binding_0.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_use_glob_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut UseGlob) {
    tokens_helper(_visitor, &mut _i.star_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_use_group_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut UseGroup) {
    tokens_helper(_visitor, &mut _i.brace_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.items) {
        let it = el.value_mut();
        _visitor.visit_use_tree_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_use_name_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut UseName) {
    _visitor.visit_ident_mut(&mut _i.ident);
}
#[cfg(feature = "full")]
pub fn visit_use_path_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut UsePath) {
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.colon2_token.spans);
    _visitor.visit_use_tree_mut(&mut *_i.tree);
}
#[cfg(feature = "full")]
pub fn visit_use_rename_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut UseRename) {
    _visitor.visit_ident_mut(&mut _i.ident);
    tokens_helper(_visitor, &mut _i.as_token.span);
    _visitor.visit_ident_mut(&mut _i.rename);
}
#[cfg(feature = "full")]
pub fn visit_use_tree_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut UseTree) {
    match *_i {
        UseTree::Path(ref mut _binding_0) => {
            _visitor.visit_use_path_mut(_binding_0);
        }
        UseTree::Name(ref mut _binding_0) => {
            _visitor.visit_use_name_mut(_binding_0);
        }
        UseTree::Rename(ref mut _binding_0) => {
            _visitor.visit_use_rename_mut(_binding_0);
        }
        UseTree::Glob(ref mut _binding_0) => {
            _visitor.visit_use_glob_mut(_binding_0);
        }
        UseTree::Group(ref mut _binding_0) => {
            _visitor.visit_use_group_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_variant_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Variant) {
    for it in &mut _i.attrs {
        _visitor.visit_attribute_mut(it)
    }
    _visitor.visit_ident_mut(&mut _i.ident);
    _visitor.visit_fields_mut(&mut _i.fields);
    if let Some(ref mut it) = _i.discriminant {
        tokens_helper(_visitor, &mut (it).0.spans);
        _visitor.visit_expr_mut(&mut (it).1);
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_vis_crate_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut VisCrate) {
    tokens_helper(_visitor, &mut _i.crate_token.span);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_vis_public_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut VisPublic) {
    tokens_helper(_visitor, &mut _i.pub_token.span);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_vis_restricted_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut VisRestricted) {
    tokens_helper(_visitor, &mut _i.pub_token.span);
    tokens_helper(_visitor, &mut _i.paren_token.span);
    if let Some(ref mut it) = _i.in_token {
        tokens_helper(_visitor, &mut it.span)
    };
    _visitor.visit_path_mut(&mut *_i.path);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_visibility_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Visibility) {
    match *_i {
        Visibility::Public(ref mut _binding_0) => {
            _visitor.visit_vis_public_mut(_binding_0);
        }
        Visibility::Crate(ref mut _binding_0) => {
            _visitor.visit_vis_crate_mut(_binding_0);
        }
        Visibility::Restricted(ref mut _binding_0) => {
            _visitor.visit_vis_restricted_mut(_binding_0);
        }
        Visibility::Inherited => {}
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_where_clause_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut WhereClause) {
    tokens_helper(_visitor, &mut _i.where_token.span);
    for mut el in Punctuated::pairs_mut(&mut _i.predicates) {
        let it = el.value_mut();
        _visitor.visit_where_predicate_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_where_predicate_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut WherePredicate) {
    match *_i {
        WherePredicate::Type(ref mut _binding_0) => {
            _visitor.visit_predicate_type_mut(_binding_0);
        }
        WherePredicate::Lifetime(ref mut _binding_0) => {
            _visitor.visit_predicate_lifetime_mut(_binding_0);
        }
        WherePredicate::Eq(ref mut _binding_0) => {
            _visitor.visit_predicate_eq_mut(_binding_0);
        }
    }
}
pub fn visit_span_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Span) {}
pub fn visit_ident_mut<V: VisitMut + ?Sized>(_visitor: &mut V, _i: &mut Ident) {}
